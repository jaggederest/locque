(import prelude P)
(import assert A)
(import typeclass::equality Eq)
(import string S)
(open A exposing assert-eq)
(open Eq exposing Equality)
(open P exposing Option::none Option::some Either::left Either::right Result::ok Result::err)
(module test::prelude::data (define transparent Empty (data Type0)) (define transparent Wrapper (data (A Type0) (n Natural) Type0 (case Wrapper::wrap (for-all (x A) (Wrapper A n))))) (define transparent Tagged (data (n Natural) Type0 (case Tagged::zero (Tagged 0)) (case Tagged::one (Tagged 1)))) (define transparent Flagged (data (b Boolean) Type0 (case Flagged::false (Flagged false)) (case Flagged::true (Flagged true)))) (define transparent Peano (data Type0 (case Peano::zero Peano) (case Peano::succ (for-all (n Peano) Peano)))) (define transparent Vec (data (A Type0) (n Peano) Type0 (case Vec::nil (Vec A Peano::zero)) (case Vec::cons (for-all (n Peano) (for-all (h A) (for-all (t (Vec A n)) (Vec A (Peano::succ n)))))))) (define transparent option-default (function (A Type0) (fallback A) (opt (P::Option A)) A (value (match (of-type opt (P::Option A)) ignored A (case Option::none fallback) (case Option::some (x A) x))))) (define transparent result-default (function (A Type0) (E Type0) (fallback A) (res (P::Result A E)) A (value (match (of-type res (P::Result A E)) ignored A (case Result::ok (ok A) ok) (case Result::err (ignored E) fallback))))) (define transparent either-sum (function (e (P::Either Natural Natural)) Natural (value (match (of-type e (P::Either Natural Natural)) ignored Natural (case Either::left (x Natural) (P::add-nat x 1)) (case Either::right (y Natural) (P::add-nat y 10)))))) (define transparent either-left (of-type (Either::left Natural Natural 1) (P::Either Natural Natural))) (define transparent either-right (of-type (Either::right Natural Natural 1) (P::Either Natural Natural))) (define transparent absurd (function (A Type0) (e Empty) A (value (match (of-type e Empty) ignored A )))) (define transparent unwrap (function (A Type0) (n Natural) (w (Wrapper A n)) A (value (match (of-type w (Wrapper A n)) ignored A (case Wrapper::wrap (x A) x))))) (define transparent tag0 Tagged::zero) (define transparent tag1 Tagged::one) (define transparent tag0-typed (of-type tag0 (Tagged 0))) (define transparent tag1-typed (of-type tag1 (Tagged 1))) (define transparent flagged-value (function (b Boolean) (x (Flagged b)) <invalid-type> (value (match (of-type x (Flagged b)) ignored <invalid-type> (case Flagged::false 0) (case Flagged::true "yes"))))) (define transparent peano-zero Peano::zero) (define transparent vec-one (Vec::cons Natural peano-zero 7 (Vec::nil Natural))) (define transparent head-vec (function (A Type0) (n Peano) (xs (Vec A (Peano::succ n))) A (value (match (of-type xs (Vec A (Peano::succ n))) ignored A (case Vec::nil (P::error A "unreachable")) (case Vec::cons (n Peano) (h A) (t (Vec A n)) h))))) (define transparent tail-vec (function (A Type0) (n Peano) (xs (Vec A (Peano::succ n))) (Vec A n) (value (match (of-type xs (Vec A (Peano::succ n))) ignored (Vec A n) (case Vec::nil (Vec::nil A)) (case Vec::cons (n Peano) (h A) (t (Vec A n)) t))))) (define transparent map-vec (function (A Type0) (B Type0) (n Peano) (f (for-all (x A) B)) (xs (Vec A n)) (Vec B n) (value (match (of-type xs (Vec A n)) ignored (Vec B n) (case Vec::nil (Vec::nil B)) (case Vec::cons (n Peano) (h A) (t (Vec A n)) (Vec::cons B n (f h) (recur A B n f t))))))) (define transparent peano-one (Peano::succ peano-zero)) (define transparent peano-two (Peano::succ peano-one)) (define transparent vec-two (Vec::cons Natural peano-one 8 vec-one)) (define transparent inc (function (x Natural) Natural (value (P::add-nat x 1)))) (define transparent main (compute (bind (_ (perform (A::assert-eq Natural (option-default Natural 1 (Option::none Natural)) 1))) (bind (_ (perform (A::assert-eq Natural (option-default Natural 1 (Option::some Natural 2)) 2))) (bind (_ (perform (A::assert-eq Natural (result-default Natural String 9 (Result::ok Natural String 5)) 5))) (bind (_ (perform (A::assert-eq Natural (result-default Natural String 9 (Result::err Natural String "no")) 9))) (bind (_ (perform (A::assert-eq Natural (either-sum either-left) 2))) (bind (_ (perform (A::assert-eq Natural (either-sum either-right) 11))) (bind (_ (perform (A::assert-eq Natural (unwrap Natural 2 (Wrapper::wrap Natural 2 9)) 9))) (bind (_ (perform (A::assert-eq Natural (flagged-value false Flagged::false) 0))) (bind (_ (perform (A::assert-eq String (flagged-value true Flagged::true) "yes"))) (bind (_ (perform (A::assert-eq Natural (head-vec Natural peano-zero vec-one) 7))) (bind (_ (perform (A::assert-eq Natural (head-vec Natural peano-zero (tail-vec Natural peano-one vec-two)) 7))) (bind (_ (perform (A::assert-eq Natural (head-vec Natural peano-zero (map-vec Natural Natural peano-one inc vec-one)) 8))) (bind (_ (perform (A::assert-eq Natural (head-vec Natural peano-zero (tail-vec Natural peano-one (map-vec Natural Natural peano-two inc vec-two))) 8))) (return tt)))))))))))))))))
