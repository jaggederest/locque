# Minimal prelude tests using the current surface syntax

import prelude as P
import assert as A
import io as IO
import string as S
import comparison as C

open A exposing assert-eq Equality end

module test::prelude::basics contains
  define transparent nums as
    P::cons Natural 1 (P::cons Natural 2 (P::cons Natural 3 (P::nil Natural)))

  define transparent empty-nums as
    P::nil Natural

  define transparent strs as
    P::cons String "a" (P::cons String "b" (P::cons String "c" (P::nil String)))

  define transparent sample-pair as
    P::pair Natural String 3 "three"

  define transparent x as
    0

  define transparent poly as
    function x Type0 returns x value
      error-prim x "poly"
    end

  define transparent check-dependent-binders as
    of-type poly for-all y as Type0 to y

  define transparent poly2 as
    function A Type0 x A returns A value
      x
    end

  define transparent check-dependent-apply as
    of-type (poly2 Natural) for-all y as Natural to Natural

  define transparent sigma-id as
    function p (there-exists x as Type0 in x) returns (there-exists y as Type0 in y) value
      p
    end

  define transparent check-dependent-sigma as
    of-type sigma-id for-all p as (there-exists a as Type0 in a) to (there-exists b as Type0 in b)

  define transparent wrap-sigma as
    function A Type0 p (there-exists x as A in A) returns (there-exists y as A in A) value
      p
    end

  define transparent check-dependent-sigma-apply as
    of-type (wrap-sigma Natural) for-all p as (there-exists x as Natural in Natural) to (there-exists y as Natural in Natural)

  define transparent compute-id as
    function A Type0 x A returns computation A compute
      return x
    end

  define transparent check-compute-id as
    of-type compute-id for-all A as Type0 to for-all x as A to computation A

  define transparent check-compute-id-apply as
    of-type (compute-id Natural 4) computation Natural

  define transparent compute-pass as
    function A Type0 c (computation A) returns computation A value
      c
    end

  define transparent check-compute-pass as
    of-type compute-pass for-all A as Type0 to for-all c as (computation A) to computation A

  define transparent check-compute-pass-apply as
    of-type (compute-pass Natural) for-all c as (computation Natural) to computation Natural

  define transparent compute-map as
    function A Type0 B Type0 f (for-all x as A to B) c (computation A) returns computation B compute
      bind x from perform c then
        return (f x)
      end
    end

  define transparent check-compute-map as
    of-type compute-map for-all A as Type0 to for-all B as Type0 to for-all f as (for-all x as A to B) to for-all c as (computation A) to computation B

  define transparent check-bind-match-list as compute
    bind xs from perform (compute return nums end) then
      perform (A::assert-eq Natural
        (match xs of-type (List Natural) as ignored returns Natural
          empty-case as 0
          cons-case with h Natural t (List Natural) as h
        end)
        1)
    end
  end

  define transparent check-bind-match-shadow as compute
    bind x from perform (compute return 1 end) then
      perform (A::assert-eq Natural
        (match (P::pair Natural Natural 2 x) of-type (Pair Natural Natural) as ignored returns Natural
          pair-case with x Natural y Natural as x
        end)
        2)
    end
  end

  define transparent check-bind-match-comp as compute
    bind xs from perform (compute return nums end) then
      bind result from perform
        (match xs of-type (List Natural) as ignored returns computation Natural
          empty-case as compute return 0 end
          cons-case with h Natural t (List Natural) as compute return h end
        end)
      then
        perform (A::assert-eq Natural result 1)
      end
    end
  end

  define transparent match-comp-shadow as
    function xs (List Natural) returns computation Natural value
      match xs of-type (List Natural) as ignored returns computation Natural
        empty-case as compute return 0 end
        cons-case with h Natural t (List Natural) as compute
          bind h from perform (compute return (P::add-nat h 1) end) then
            return h
          end
        end
      end
    end

  define transparent check-match-comp-shadow as compute
    bind result from perform (match-comp-shadow nums) then
      perform (A::assert-eq Natural result 2)
    end
  end

  define transparent comp-val as
    compute
      return 3
    end

  define transparent check-comp-val as
    of-type comp-val computation Natural

  define transparent compute-nest as
    function A Type0 x A returns computation (computation A) compute
      return (compute return x end)
    end

  define transparent check-compute-nest as
    of-type compute-nest for-all A as Type0 to for-all x as A to computation (computation A)

  define transparent compute-perform-nest as
    function A Type0 x A returns computation A compute
      perform (compute return x end)
    end

  define transparent check-compute-perform-nest as
    of-type compute-perform-nest for-all A as Type0 to for-all x as A to computation A

  define transparent bind-shadow as
    function A Type0 x A returns computation A compute
      bind x from perform (compute-id A x) then
        return x
      end
    end

  define transparent check-bind-shadow as
    of-type bind-shadow for-all A as Type0 to for-all x as A to computation A

  define transparent bind-shadow-nested as
    function A Type0 x A returns computation A compute
      bind y from perform (compute-id A x) then
        bind x from perform (compute-id A y) then
          return x
        end
      end
    end

  define transparent check-bind-shadow-nested as
    of-type bind-shadow-nested for-all A as Type0 to for-all x as A to computation A

  define transparent bind-shadow-global as
    compute
      bind x from perform (compute-id Natural 5) then
        return x
      end
    end

  define transparent check-bind-shadow-global as
    of-type bind-shadow-global computation Natural

  define transparent bind-sigma as
    function A Type0 p (there-exists x as A in A) returns computation (there-exists y as A in A) compute
      bind q from perform (compute return p end) then
        return q
      end
    end

  define transparent check-bind-sigma as
    of-type bind-sigma for-all A as Type0 to for-all p as (there-exists x as A in A) to computation (there-exists y as A in A)

  define transparent match-sigma as
    function A Type0 xs (List Natural) a (there-exists x as A in A) b (there-exists y as A in A) returns (there-exists z as A in A) value
      match xs of-type (List Natural) as ignored returns there-exists z as A in A
        empty-case as a
        cons-case with h Natural t (List Natural) as b
      end
    end

  define transparent check-match-sigma as
    of-type match-sigma for-all A as Type0 to for-all xs as (List Natural) to for-all a as (there-exists x as A in A) to for-all b as (there-exists y as A in A) to (there-exists z as A in A)

  define transparent match-sigma-comp as
    function A Type0 xs (List Natural) a (there-exists x as A in A) b (there-exists y as A in A) returns computation (there-exists z as A in A) value
      match xs of-type (List Natural) as ignored returns computation there-exists z as A in A
        empty-case as compute return a end
        cons-case with h Natural t (List Natural) as compute return b end
      end
    end

  define transparent check-match-sigma-comp as
    of-type match-sigma-comp for-all A as Type0 to for-all xs as (List Natural) to for-all a as (there-exists x as A in A) to for-all b as (there-exists y as A in A) to computation (there-exists z as A in A)

  define transparent compute-return-natural as
    compute
      return 41
    end

  define transparent check-perform-value as compute
    bind x from perform compute-return-natural then
      perform (A::assert-eq Natural x 41)
    end
  end

  define transparent compute-return-compute as
    compute
      return (compute return 5 end)
    end

  define transparent check-perform-nested as compute
    bind c from perform compute-return-compute then
      bind x from perform c then
        perform (A::assert-eq Natural x 5)
      end
    end
  end

  define transparent check-sequence-nested as compute
    sequence
      (compute
        sequence
          (A::assert-eq Natural 2 2)
          (A::assert-eq Natural 3 3)
        end
      end)
      (A::assert-eq Natural 1 1)
    end
  end

  define transparent check-match-comp-bool as compute
    bind result from perform
      (match true of-type Boolean as ignored returns computation Natural
        false-case as compute return 0 end
        true-case as compute return 1 end
      end)
    then
      perform (A::assert-eq Natural result 1)
    end
  end

  define transparent add2 as
    function x Natural returns Natural value
      P::add-nat x 2
    end

  define transparent hello as compute
    bind ignored from perform (IO::print "Hello, locque!") then
      return tt
    end
  end

  define transparent check-arithmetic as compute
    perform (A::assert-eq Natural (add2 3) 5)
  end

  define transparent check-open as
    function A Type0 x A y A requires Equality A returns computation Unit value
      compute
        perform (assert-eq A x y)
      end
    end

  define transparent check-open-use as compute
    perform (check-open Natural 7 7)
  end

  define transparent check-sequence as compute
    sequence
      (A::assert-eq Natural 1 1)
      (A::assert-eq Natural 2 2)
    end
  end

  define transparent check-prelude-nat as compute
    sequence
      (A::assert-eq Natural (P::add-nat 2 5) 7)
      (A::assert-eq Natural (P::sub-nat 5 2) 3)
      (A::assert-eq Natural (P::sub-nat 2 5) 0)
    end
  end

  define transparent check-prelude-id as compute
    perform (A::assert-eq String (P::id "hi") "hi")
  end

  define transparent check-string as compute
    perform (A::assert-eq String (S::join-with "-" (S::split-on "-" "a-b")) "a-b")
  end

  define transparent check-string-more as compute
    sequence
      (A::assert-eq String (S::trim "  hi  ") "hi")
      (A::assert-eq String (S::concat "a" "b") "ab")
      (A::assert-eq Natural (S::length "abc") 3)
      (A::assert-eq Boolean (S::eq "x" "x") true)
      (A::assert-eq String (S::reverse "abc") "cba")
    end
  end

  define transparent check-if-bool as compute
    sequence
      (A::assert-eq String (P::if-bool String true "yes" "no") "yes")
      (A::assert-eq Boolean (P::not false) true)
      (A::assert-eq String (P::if-bool String false "yes" "no") "no")
      (A::assert-eq Boolean (P::is-falsy false) true)
      (A::assert-eq Boolean (P::is-falsy true) false)
    end
  end

  define transparent check-prelude-list-more as compute
    sequence
      (A::assert-eq Natural (P::length-list Natural empty-nums) 0)
      (A::assert-eq Natural
        (P::length-list Natural (P::append Natural empty-nums nums))
        3)
      (A::assert-eq Natural
        (P::length-list Natural (P::append Natural nums empty-nums))
        3)
      (A::assert-eq Natural
        (P::length-list Natural (P::tail Natural (P::cons Natural 9 (P::nil Natural))))
        0)
      (A::assert-eq String
        (P::head String (P::reverse strs))
        "c")
    end
  end

  define transparent check-prelude-match-prim as compute
    sequence
      (A::assert-eq String
        (P::match-list Natural String nums
          (function u Unit returns String value
            "empty"
          end)
          (function h Natural t (List Natural) returns String value
            "nonempty"
          end))
        "nonempty")
      (A::assert-eq String
        (P::match-list Natural String empty-nums
          (function u Unit returns String value
            "empty"
          end)
          (function h Natural t (List Natural) returns String value
            "nonempty"
          end))
        "empty")
      (A::assert-eq String
        (P::match-bool String false
          (function u Unit returns String value
            "no"
          end)
          (function u Unit returns String value
            "yes"
          end))
        "no")
      (A::assert-eq String
        (P::match-pair Natural String String sample-pair
          (function u Unit returns String value
            "never"
          end)
          (function a Natural b String returns String value
            b
          end))
        "three")
    end
  end

  define transparent check-list-ops as compute
    sequence
      (A::assert-eq Natural (P::length-list Natural nums) 3)
      (A::assert-eq Natural (P::head Natural nums) 1)
      (A::assert-eq Natural (P::length-list Natural (P::tail Natural nums)) 2)
      (A::assert-eq Natural
        (P::length-list Natural
          (P::append Natural nums (P::cons Natural 4 (P::nil Natural))))
        4)
    end
  end

  define transparent check-map-filter-fold as compute
    sequence
      (A::assert-eq Natural
        (P::head Natural
          (P::map Natural Natural
            (function x Natural returns Natural value
              P::add-nat x x
            end)
            nums))
        2)
      (A::assert-eq Natural
        (P::length-list Natural
          (P::filter Natural
            (function x Natural returns Boolean value
              C::gt-nat x 1
            end)
            nums))
        2)
      (A::assert-eq Natural
        (P::fold Natural Natural
          (function acc Natural x Natural returns Natural value
            P::add-nat acc x
          end)
          0
          nums)
        6)
    end
  end

  define transparent check-list-match as compute
    perform (A::assert-eq Natural
      (match nums of-type (List Natural) as ignored returns Natural
        empty-case as 0
        cons-case with h Natural t (List Natural) as h
      end)
      1)
  end

  define transparent check-pair-ops as compute
    sequence
      (A::assert-eq Natural (P::fst Natural String sample-pair) 3)
      (A::assert-eq String (P::snd Natural String sample-pair) "three")
      (A::assert-eq Natural
        (P::length-list Natural
          (P::pair-to-list Natural (P::pair Natural Natural 1 2)))
        2)
    end
  end

  define transparent check-pair-match as compute
    perform (A::assert-eq Natural
      (match sample-pair of-type (Pair Natural String) as ignored returns Natural
        pair-case with a Natural b String as a
      end)
      3)
  end

  define transparent check-match as compute
    perform (A::assert-eq Natural
      (match true of-type Boolean as ignored returns Natural
        false-case as 0
        true-case as 1
      end)
      1)
  end

  define transparent check-let as compute
    perform (A::assert-eq Natural
      (let value x be 4 in
        P::add-nat x 1
      end)
      5)
  end

  define transparent all-tests as compute
    sequence
      hello
      check-arithmetic
      check-sequence
      check-prelude-nat
      check-prelude-id
      check-string
      check-string-more
      check-if-bool
      check-prelude-list-more
      check-prelude-match-prim
      check-bind-match-list
      check-bind-match-shadow
      check-bind-match-comp
      check-match-comp-shadow
      check-perform-value
      check-perform-nested
      check-sequence-nested
      check-match-comp-bool
      check-list-ops
      check-map-filter-fold
      check-list-match
      check-pair-ops
      check-pair-match
      check-match
      check-let
      check-open-use
    end
  end

  define transparent main as compute
    perform all-tests
  end
end
