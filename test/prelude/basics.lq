# Minimal prelude tests using the current surface syntax

import prelude as P
import arithmetic as Ar
import assert as A
import io as IO
import string as S
import list as L
import typeclass::equality as Eq
import typeclass::order as Order
import type_aliases as Types
import test::helpers as TH

open A exposing assert-eq end
open Eq exposing Equality end

module test::prelude::basics contains
  define transparent nums as
    [1, 2, 3]

  define transparent empty-nums as
    of-type [] (List Natural)

  define transparent strs as
    ["a", "b", "c"]

  define transparent sample-pair as
    P::pair Natural String 3 "three"

  define transparent x as
    0

  define transparent poly as
    function x Type0 returns x value
      P::error x "poly"
    end

  define transparent check-dependent-binders as
    of-type poly for-all y as Type0 to y

  define transparent poly2 as
    function A Type0 x A returns A value
      x
    end

  define transparent check-dependent-apply as
    of-type (poly2 Natural) (Types::Function Natural Natural)

  define transparent sigma-id as
    function p (there-exists x as Type0 in x) returns (there-exists y as Type0 in y) value
      p
    end

  define transparent check-dependent-sigma as
    of-type sigma-id for-all p as (there-exists a as Type0 in a) to (there-exists b as Type0 in b)

  define transparent wrap-sigma as
    function A Type0 p (there-exists x as A in A) returns (there-exists y as A in A) value
      p
    end

  define transparent check-dependent-sigma-apply as
    of-type (wrap-sigma Natural)
      (Types::Function
        (there-exists x as Natural in Natural)
        (there-exists y as Natural in Natural))

  define transparent compute-id as
    function A Type0 x A returns computation A compute
      return x
    end

  define transparent check-compute-id as
    of-type compute-id for-all A as Type0 to (Types::Function A (computation A))

  define transparent check-compute-id-apply as
    of-type (compute-id Natural 4) computation Natural

  define transparent compute-pass as
    function A Type0 c (computation A) returns computation A value
      c
    end

  define transparent check-compute-pass as
    of-type compute-pass for-all A as Type0 to (Types::Function (computation A) (computation A))

  define transparent check-compute-pass-apply as
    of-type (compute-pass Natural) (Types::Function (computation Natural) (computation Natural))

  define transparent compute-map as
    function A Type0 B Type0 f (Types::Function A B) c (computation A) returns computation B compute
      bind x from perform c then
        return (f x)
      end
    end

  define transparent check-compute-map as
    of-type compute-map for-all A as Type0 to for-all B as Type0 to for-all f as (Types::Function A B) to
      (Types::Function (computation A) (computation B))

  define transparent check-bind-match-list as compute
    bind xs from perform (compute return nums end) then
      perform (A::assert-eq Natural
        (match xs of-type (List Natural) as ignored returns Natural
          case List::empty as 0
          case List::cons with h Natural t (List Natural) as h
        end)
        1)
    end
  end

  define transparent check-bind-match-shadow as compute
    bind x from perform (compute return 1 end) then
      perform (A::assert-eq Natural
        (match (P::pair Natural Natural 2 x) of-type (Pair Natural Natural) as ignored returns Natural
          case Pair::pair with x Natural y Natural as x
        end)
        2)
    end
  end

  define transparent check-bind-match-comp as compute
    bind xs from perform (compute return nums end) then
      bind result from perform
        (match xs of-type (List Natural) as ignored returns computation Natural
          case List::empty as compute return 0 end
          case List::cons with h Natural t (List Natural) as compute return h end
        end)
      then
        perform (A::assert-eq Natural result 1)
      end
    end
  end

  define transparent match-comp-shadow as
    function xs (List Natural) returns computation Natural value
      match xs of-type (List Natural) as ignored returns computation Natural
        case List::empty as compute return 0 end
        case List::cons with h Natural t (List Natural) as compute
          bind h from perform (compute return (Ar::add h 1) end) then
            return h
          end
        end
      end
    end

  define transparent check-match-comp-shadow as compute
    bind result from perform (match-comp-shadow nums) then
      perform (A::assert-eq Natural result 2)
    end
  end

  define transparent comp-val as
    compute
      return 3
    end

  define transparent check-comp-val as
    of-type comp-val computation Natural

  define transparent compute-nest as
    function A Type0 x A returns computation (computation A) compute
      return (compute return x end)
    end

  define transparent check-compute-nest as
    of-type compute-nest for-all A as Type0 to (Types::Function A (computation (computation A)))

  define transparent compute-perform-nest as
    function A Type0 x A returns computation A compute
      perform (compute return x end)
    end

  define transparent check-compute-perform-nest as
    of-type compute-perform-nest for-all A as Type0 to (Types::Function A (computation A))

  define transparent bind-shadow as
    function A Type0 x A returns computation A compute
      bind x from perform (compute-id A x) then
        return x
      end
    end

  define transparent check-bind-shadow as
    of-type bind-shadow for-all A as Type0 to (Types::Function A (computation A))

  define transparent bind-shadow-nested as
    function A Type0 x A returns computation A compute
      bind y from perform (compute-id A x) then
        bind x from perform (compute-id A y) then
          return x
        end
      end
    end

  define transparent check-bind-shadow-nested as
    of-type bind-shadow-nested for-all A as Type0 to (Types::Function A (computation A))

  define transparent bind-shadow-global as
    compute
      bind x from perform (compute-id Natural 5) then
        return x
      end
    end

  define transparent check-bind-shadow-global as
    of-type bind-shadow-global computation Natural

  define transparent bind-sigma as
    function A Type0 p (there-exists x as A in A) returns computation (there-exists y as A in A) compute
      bind q from perform (compute return p end) then
        return q
      end
    end

  define transparent check-bind-sigma as
    of-type bind-sigma for-all A as Type0 to
      (Types::Function
        (there-exists x as A in A)
        (computation (there-exists y as A in A)))

  define transparent match-sigma as
    function A Type0 xs (List Natural) a (there-exists x as A in A) b (there-exists y as A in A) returns (there-exists z as A in A) value
      match xs of-type (List Natural) as ignored returns there-exists z as A in A
        case List::empty as a
        case List::cons with h Natural t (List Natural) as b
      end
    end

  define transparent check-match-sigma as
    of-type match-sigma for-all A as Type0 to
      (Types::Function
        (List Natural)
        (Types::Function
          (there-exists x as A in A)
          (Types::Function
            (there-exists y as A in A)
            (there-exists z as A in A))))

  define transparent match-sigma-comp as
    function A Type0 xs (List Natural) a (there-exists x as A in A) b (there-exists y as A in A) returns computation (there-exists z as A in A) value
      match xs of-type (List Natural) as ignored returns computation (there-exists z as A in A)
        case List::empty as compute return a end
        case List::cons with h Natural t (List Natural) as compute return b end
      end
    end

  define transparent check-match-sigma-comp as
    of-type match-sigma-comp for-all A as Type0 to
      (Types::Function
        (List Natural)
        (Types::Function
          (there-exists x as A in A)
          (Types::Function
            (there-exists y as A in A)
            (computation (there-exists z as A in A)))))

  define transparent compute-return-natural as
    compute
      return 41
    end

  define transparent check-perform-value as compute
    bind x from perform compute-return-natural then
      perform (A::assert-eq Natural x 41)
    end
  end

  define transparent compute-return-compute as
    compute
      return (compute return 5 end)
    end

  define transparent check-perform-nested as compute
    bind c from perform compute-return-compute then
      bind x from perform c then
        perform (A::assert-eq Natural x 5)
      end
    end
  end

  define transparent check-sequence-nested as compute
    perform (P::sequence-unit
      [
        (compute
          perform (P::sequence-unit
            [
              (A::assert-eq Natural 2 2)
            , (A::assert-eq Natural 3 3)
            ])
        end)
      , (A::assert-eq Natural 1 1)
      ])
  end

  define transparent check-match-comp-bool as compute
    bind result from perform
      (match true of-type Boolean as ignored returns computation Natural
        case Boolean::false as compute return 0 end
        case Boolean::true as compute return 1 end
      end)
    then
      perform (A::assert-eq Natural result 1)
    end
  end

  define transparent add2 as
    function x Natural returns Natural value
      Ar::add x 2
    end

  define transparent hello as compute
    perform (TH::assert-single-output Unit "Hello, locque!" (IO::print "Hello, locque!"))
  end

  define transparent check-arithmetic as compute
    perform (A::assert-eq Natural (add2 3) 5)
  end

  define transparent check-open as
    function A Type0 x A y A requires Equality A returns computation Unit value
      compute
        perform (assert-eq A x y)
      end
    end

  define transparent check-open-use as compute
    perform (check-open Natural 7 7)
  end

  define transparent check-sequence as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural 1 1)
      , (A::assert-eq Natural 2 2)
      ])
  end

  define transparent check-prelude-nat as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural (Ar::add 2 5) 7)
      , (A::assert-eq Natural (Ar::subtract 5 2) 3)
      , (A::assert-eq Natural (Ar::subtract 2 5) 0)
      ])
  end

  define transparent check-prelude-id as compute
    perform (A::assert-eq String (P::id String "hi") "hi")
  end

  define transparent check-string as compute
    perform (A::assert-eq String (S::join-with "-" (S::split-on "-" "a-b")) "a-b")
  end

  define transparent check-string-more as compute
    perform (P::sequence-unit
      [
        (A::assert-eq String (S::trim "  hi  ") "hi")
      , (A::assert-eq String (S::concat "a" "b") "ab")
      , (A::assert-eq Natural (S::length "abc") 3)
      , (A::assert-eq Boolean (Eq::equals String "x" "x") true)
      , (A::assert-eq String (S::reverse "abc") "cba")
      ])
  end

  define transparent check-if-bool as compute
    perform (P::sequence-unit
      [
        (A::assert-eq String
                                                (match true of-type Boolean as ignored returns String
                                                  case Boolean::false as "no"
                                                  case Boolean::true as "yes"
                                                end)
                                                "yes")
      , (A::assert-eq Boolean (P::not false) true)
      , (A::assert-eq String
                                                    (match false of-type Boolean as ignored returns String
                                                      case Boolean::false as "no"
                                                      case Boolean::true as "yes"
                                                    end)
                                                    "no")
      , (A::assert-eq Boolean (P::is-falsy false) true)
      , (A::assert-eq Boolean (P::is-falsy true) false)
      ])
  end

  define transparent check-prelude-list-more as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural (P::length-list Natural empty-nums) 0)
      , (A::assert-eq Natural
                                                  (P::length-list Natural (P::append Natural empty-nums nums))
                                                  3)
      , (A::assert-eq Natural
                                                    (P::length-list Natural (P::append Natural nums empty-nums))
                                                    3)
      , (A::assert-eq Natural
                                                      (P::length-list Natural (P::tail Natural [9]))
                                                      0)
      , (A::assert-eq String
                                                        (P::head String (L::reverse String strs))
                                                        "c")
      ])
  end

  define transparent check-prelude-match as compute
    perform (P::sequence-unit
      [
        (A::assert-eq String
                                                (match nums of-type (List Natural) as ignored returns String
                                                  case List::empty as "empty"
                                                  case List::cons with h Natural t (List Natural) as "nonempty"
                                                end)
                                                "nonempty")
      , (A::assert-eq String
                                                  (match empty-nums of-type (List Natural) as ignored returns String
                                                    case List::empty as "empty"
                                                    case List::cons with h Natural t (List Natural) as "nonempty"
                                                  end)
                                                  "empty")
      , (A::assert-eq String
                                                    (match false of-type Boolean as ignored returns String
                                                      case Boolean::false as "no"
                                                      case Boolean::true as "yes"
                                                    end)
                                                    "no")
      , (A::assert-eq String
                                                      (match sample-pair of-type (Pair Natural String) as ignored returns String
                                                        case Pair::pair with a Natural b String as b
                                                      end)
                                                      "three")
      ])
  end

  define transparent check-list-ops as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural (P::length-list Natural nums) 3)
      , (A::assert-eq Natural (P::head Natural nums) 1)
      , (A::assert-eq Natural (P::length-list Natural (P::tail Natural nums)) 2)
      , (A::assert-eq Natural
                                                      (P::length-list Natural
                                                        (P::append Natural nums [4]))
                                                      4)
      ])
  end

  define transparent check-map-filter-fold as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural
                                                (P::head Natural
                                                  (P::map Natural Natural
                                                    (function x Natural returns Natural value
                                                      Ar::add x x
                                                    end)
                                                    nums))
                                                2)
      , (A::assert-eq Natural
                                                  (P::length-list Natural
                                                    (P::filter Natural
                                                      (function x Natural returns Boolean value
                                                        Order::greater-than Natural x 1
                                                      end)
                                                      nums))
                                                  2)
      , (A::assert-eq Natural
                                                    (P::fold Natural Natural
                                                      (function acc Natural x Natural returns Natural value
                                                        Ar::add acc x
                                                      end)
                                                      0
                                                      nums)
                                                    6)
      ])
  end

  define transparent check-list-match as compute
    perform (A::assert-eq Natural
      (match nums of-type (List Natural) as ignored returns Natural
        case List::empty as 0
        case List::cons with h Natural t (List Natural) as h
      end)
      1)
  end

  define transparent check-pair-ops as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Natural (P::fst Natural String sample-pair) 3)
      , (A::assert-eq String (P::snd Natural String sample-pair) "three")
      , (A::assert-eq Natural
                                                    (P::length-list Natural
                                                      (P::pair-to-list Natural (P::pair Natural Natural 1 2)))
                                                    2)
      ])
  end

  define transparent check-pair-match as compute
    perform (A::assert-eq Natural
      (match sample-pair of-type (Pair Natural String) as ignored returns Natural
        case Pair::pair with a Natural b String as a
      end)
      3)
  end

  define transparent check-match as compute
    perform (A::assert-eq Natural
      (match true of-type Boolean as ignored returns Natural
        case Boolean::false as 0
        case Boolean::true as 1
      end)
      1)
  end

  define transparent check-let as compute
    perform (A::assert-eq Natural
      (let value x be 4 in
        Ar::add x 1
      end)
      5)
  end

  define transparent all-tests as compute
    perform (P::sequence-unit
      [
        hello
      , check-arithmetic
      , check-sequence
      , check-prelude-nat
      , check-prelude-id
      , check-string
      , check-string-more
      , check-if-bool
      , check-prelude-list-more
      , check-prelude-match
      , check-bind-match-list
      , check-bind-match-shadow
      , check-bind-match-comp
      , check-match-comp-shadow
      , check-perform-value
      , check-perform-nested
      , check-sequence-nested
      , check-match-comp-bool
      , check-list-ops
      , check-map-filter-fold
      , check-list-match
      , check-pair-ops
      , check-pair-match
      , check-match
      , check-let
      , check-open-use
      ])
  end

  define transparent main as compute
    perform all-tests
  end
end
