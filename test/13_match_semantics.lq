import Prelude as P
import Assert as A

module MatchSemantics contains

  define transparent test-list-empty-case as computation
    bind empty-list <- P.nil then
    bind result <- P.match empty-list
      (lambda () "empty")
      (lambda h -> lambda t -> "cons") then
    bind _ <- perform io (A.assert-eq-string result "empty") then
    return P.tt

  define transparent test-list-cons-case as computation
    bind non-empty <- P.cons "first" (P.cons "second" P.nil) then
    bind result <- P.match non-empty
      (lambda () "empty")
      (lambda h -> lambda t -> h) then
    bind _ <- perform io (A.assert-eq-string result "first") then
    return P.tt

  define transparent test-bool-false-case as computation
    bind result <- P.match false
      (lambda () "false-branch")
      (lambda () "true-branch") then
    bind _ <- perform io (A.assert-eq-string result "false-branch") then
    return P.tt

  define transparent test-bool-true-case as computation
    bind result <- P.match true
      (lambda () "false-branch")
      (lambda () "true-branch") then
    bind _ <- perform io (A.assert-eq-string result "true-branch") then
    return P.tt

  define transparent test-pair-case as computation
    bind my-pair <- P.pair "left" "right" then
    bind result <- P.match my-pair
      (lambda () "never")
      (lambda a -> lambda b -> a) then
    bind _ <- perform io (A.assert-eq-string result "left") then
    return P.tt

  define transparent main as computation
    bind _ <- test-list-empty-case then
    bind _ <- test-list-cons-case then
    bind _ <- test-bool-false-case then
    bind _ <- test-bool-true-case then
    bind _ <- test-pair-case then
    return P.tt
end
