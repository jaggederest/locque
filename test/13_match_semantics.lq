import prelude as P
import assert as A

module LMatchSemantics contains

  define transparent test-list-empty-case as computation
    bind P.nil as empty-list then
    bind P.match-list empty-list
      (lambda -> "empty")
      (lambda h -> lambda t -> "cons") as result then
    bind perform io (A.assert-eq-string result "empty") as _ then
    return P.tt

  define transparent test-list-cons-case as computation
    bind P.cons "first" (P.cons "second" P.nil) as non-empty then
    bind P.match-list non-empty
      (lambda -> "empty")
      (lambda h -> lambda t -> h) as result then
    bind perform io (A.assert-eq-string result "first") as _ then
    return P.tt

  define transparent test-bool-false-case as computation
    bind P.match-bool false
      (lambda -> "false-branch")
      (lambda -> "true-branch") as result then
    bind perform io (A.assert-eq-string result "false-branch") as _ then
    return P.tt

  define transparent test-bool-true-case as computation
    bind P.match-bool true
      (lambda -> "false-branch")
      (lambda -> "true-branch") as result then
    bind perform io (A.assert-eq-string result "true-branch") as _ then
    return P.tt

  define transparent test-pair-case as computation
    bind P.pair "left" "right" as my-pair then
    bind P.match-pair my-pair
      (lambda -> "never")
      (lambda a -> lambda b -> a) as result then
    bind perform io (A.assert-eq-string result "left") as _ then
    return P.tt

  define transparent main as computation
    bind test-list-empty-case as _ then
    bind test-list-cons-case as _ then
    bind test-bool-false-case as _ then
    bind test-bool-true-case as _ then
    bind test-pair-case as _ then
    return P.tt
end
