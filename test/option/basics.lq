# Option helpers tests

import assert as A
import arithmetic as Ar
import logic as L
import option as Opt
import prelude as P
import result as Res
import typeclass::equality as Eq

open A exposing assert-eq end
open Eq exposing Equality end
open P exposing Option::none Option::some Result::ok Result::err end

module test::option::basics contains
  define transparent inc as
    function x Natural returns Natural value
      Ar::add x 1
    end

  define transparent some1 as Option::some Natural 1
  define transparent none-nat as Option::none Natural

  define transparent map-some as
    Opt::map Natural Natural inc some1

  define transparent map-none as
    Opt::map Natural Natural inc none-nat

  define transparent bind-some as
    Opt::and-then Natural Natural
      (function x Natural returns (P::Option Natural) value
        Option::some Natural (Ar::add x 3)
      end)
      some1

  define transparent bind-none as
    Opt::and-then Natural Natural
      (function x Natural returns (P::Option Natural) value
        Option::some Natural (Ar::add x 3)
      end)
      none-nat

  define transparent to-result-none as
    Opt::to-result Natural String "missing" none-nat

  define transparent to-result-some as
    Opt::to-result Natural String "missing" some1

  define transparent not-eq-1-2 as
    unpack (L::decide-eq-nat 1 2) as flag proof in
      match flag of-type Boolean as flag returns (L::Not (equal Natural 1 2))
        case Boolean::false as proof
        case Boolean::true as P::error (L::Not (equal Natural 1 2)) "expected false"
      end
    end

  define transparent decidable-none as
    Opt::to-decidable (equal Natural 1 2)
      (function ignored Unit returns (L::Not (equal Natural 1 2)) value
        not-eq-1-2
      end)
      (Option::none (equal Natural 1 2))

  define transparent decidable-some as
    Opt::to-decidable (equal Natural 1 1)
      (function ignored Unit returns (L::Not (equal Natural 1 1)) value
        P::error (L::Not (equal Natural 1 1)) "unexpected none proof"
      end)
      (Option::some (equal Natural 1 1) (reflexive Natural 1))

  define transparent main as compute
    perform (P::sequence-unit
      [
        (assert-eq Boolean (Opt::is-some Natural some1) true)
      , (assert-eq Boolean (Opt::is-none Natural none-nat) true)
      , (assert-eq Natural (Opt::unwrap-or Natural 0 map-some) 2)
      , (assert-eq Natural (Opt::unwrap-or Natural 0 map-none) 0)
      , (assert-eq Natural (Opt::unwrap-or Natural 0 bind-some) 4)
      , (assert-eq Natural (Opt::unwrap-or Natural 0 bind-none) 0)
      , (assert-eq Boolean (Res::is-err Natural String to-result-none) true)
      , (assert-eq Boolean (Res::is-ok Natural String to-result-some) true)
      , (assert-eq Boolean
          (L::decidable-flag (equal Natural 1 2) decidable-none)
          false)
      , (assert-eq Boolean
          (L::decidable-flag (equal Natural 1 1) decidable-some)
          true)
      ])
  end
end
