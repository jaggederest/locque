# Project checks for lib/test parity

import arithmetic as Ar
import assert as A
import dictionary as Dict
import file as File
import list as L
import prelude as P
import string as S
import typeclass::order as Order
import typeclass::hash as Hash
import typeclass::equality as Eq

module test::project contains
  define transparent upper-start as char-code-prim "A"
  define transparent upper-end as char-code-prim "Z"

  define transparent is-upper-code as
    function code Natural returns Boolean value
      match (Order::less-or-equal Natural upper-start code) of-type Boolean as ignored returns Boolean
        case Boolean::false as false
        case Boolean::true as Order::less-or-equal Natural code upper-end
      end
    end

  define transparent has-uppercase-chars as
    function chars (List String) returns Boolean value
      match chars of-type (List String) as ignored returns Boolean
        case List::empty as false
        case List::cons with h String t (List String) as
          match (is-upper-code (char-code-prim h)) of-type Boolean as ignored returns Boolean
            case Boolean::true as true
            case Boolean::false as recur t
          end
      end
    end

  define transparent has-uppercase as
    function path String returns Boolean value
      has-uppercase-chars (string-to-list-prim path)
    end

  define transparent uppercase-paths as
    function paths (List String) returns (List String) value
      P::filter String has-uppercase paths
    end

  define transparent uppercase-message as
    function paths (List String) returns String value
      S::concat "Uppercase path(s) are not allowed: "
        (S::join-with ", " paths)
    end

  define transparent strip-prefix as
    function prefix String path String returns String value
      match (S::starts-with prefix path) of-type Boolean as ignored returns String
        case Boolean::true as
          let value prefix-len be S::length prefix in
            let value path-len be S::length path in
              S::substring prefix-len (Ar::subtract path-len prefix-len) path
            end
          end
        case Boolean::false as path
      end
    end

  define transparent lib-to-test as
    function lib-path String returns String value
      S::concat "test/" (strip-prefix "lib/" lib-path)
    end

  define transparent missing-message as
    function missing (List String) returns String value
      S::concat "Missing test file(s) for lib modules: "
        (S::join-with ", " missing)
    end

  define transparent path-entry as
    function path String returns (Pair String Unit) value
      P::pair String Unit path Unit::tt
    end

  define transparent paths-to-dict as
    function paths (List String) returns (Dictionary String Unit) value
      Dict::from-list String Unit
        (P::map String (Pair String Unit) path-entry paths)
    end

  define transparent is-missing as
    function dict (Dictionary String Unit) path String returns Boolean value
      P::not (Dict::member String Unit path dict)
    end

  define transparent missing-tests as
    function expected (List String) existing (Dictionary String Unit) returns (List String) value
      P::filter String (is-missing existing) expected
    end

  define transparent assert-lib-tests as
    function lib-files (List String)
             test-files (List String)
    returns computation Unit value
      let value upper-all be P::append String (uppercase-paths lib-files) (uppercase-paths test-files) in
        let value expected be P::map String String lib-to-test lib-files in
          let value test-dict be paths-to-dict test-files in
            let value missing be missing-tests expected test-dict in
              compute
                perform (P::sequence-unit
                  [
                    (A::assert-false (uppercase-message upper-all)
                      (P::not (L::is-empty String upper-all)))
                  , (A::assert-false (missing-message missing)
                      (P::not (L::is-empty String missing)))
                  ])
              end
            end
          end
        end
      end
    end

  define transparent check-lib-tests as compute
    bind lib-files from perform (File::walk-lq "lib" (of-type [] (List String))) then
      bind test-files from perform (File::walk-lq "test" ["test/tmp"]) then
        perform (assert-lib-tests lib-files test-files)
      end
    end
  end

  define transparent main as compute
    perform (P::sequence-unit
      [
        check-lib-tests
      ])
  end
end
