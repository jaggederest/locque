# Project checks for lib/test parity

import assert as A
import file as File
import list as L
import prelude as P
import string as S
import typeclass::equality as Eq

open S exposing Character end

module test::project contains
  define transparent has-uppercase as
    function path String returns Boolean value
      L::any Character
        (function c Character returns Boolean value
          S::class-contains S::upper-class c
        end)
        (S::to-list path)
    end

  define transparent entry-info as
    function entry (Pair String Boolean) returns (Pair String (Pair Boolean Boolean)) value
      let value path be File::walk-path entry in
        let value is-dir be File::walk-is-directory entry in
          let value is-lq be
            match is-dir of-type Boolean as ignored returns Boolean
              case Boolean::true as false
              case Boolean::false as S::ends-with ".lq" path
            end
          in
            let value has-upper be
              match is-lq of-type Boolean as ignored returns Boolean
                case Boolean::true as has-uppercase path
                case Boolean::false as false
              end
            in
              P::pair String (Pair Boolean Boolean) path (P::pair Boolean Boolean is-lq has-upper)
            end
          end
        end
      end
    end

  define transparent entry-infos as
    function entries (List (Pair String Boolean)) returns (List (Pair String (Pair Boolean Boolean))) value
      P::map (Pair String Boolean) (Pair String (Pair Boolean Boolean)) entry-info entries
    end

  define transparent info-path as
    function info (Pair String (Pair Boolean Boolean)) returns String value
      match info of-type (Pair String (Pair Boolean Boolean)) as ignored returns String
        case Pair::pair with path String ignored (Pair Boolean Boolean) as path
      end
    end

  define transparent info-is-lq as
    function info (Pair String (Pair Boolean Boolean)) returns Boolean value
      match info of-type (Pair String (Pair Boolean Boolean)) as ignored returns Boolean
        case Pair::pair with ignored String flags (Pair Boolean Boolean) as
          P::fst Boolean Boolean flags
      end
    end

  define transparent info-has-uppercase as
    function info (Pair String (Pair Boolean Boolean)) returns Boolean value
      match info of-type (Pair String (Pair Boolean Boolean)) as ignored returns Boolean
        case Pair::pair with ignored String flags (Pair Boolean Boolean) as
          P::snd Boolean Boolean flags
      end
    end

  define transparent lq-file-paths as
    function infos (List (Pair String (Pair Boolean Boolean))) returns (List String) value
      let value files be P::filter (Pair String (Pair Boolean Boolean)) info-is-lq infos in
        P::map (Pair String (Pair Boolean Boolean)) String info-path files
      end
    end

  define transparent uppercase-paths as
    function infos (List (Pair String (Pair Boolean Boolean))) returns (List String) value
      let value files be P::filter (Pair String (Pair Boolean Boolean)) info-has-uppercase infos in
        P::map (Pair String (Pair Boolean Boolean)) String info-path files
      end
    end

  define transparent uppercase-message as
    function paths (List String) returns String value
      S::concat "Uppercase path(s) are not allowed: "
        (S::join-with ", " paths)
    end

  define transparent drop-first-segment as
    function path String returns String value
      let value segments be S::split-on "/" path in
        let value rest be P::tail String segments in
          S::join-with "/" rest
        end
      end
    end

  define transparent lib-to-test as
    function lib-path String returns String value
      S::concat "test/" (drop-first-segment lib-path)
    end

  define transparent missing-message as
    function missing (List String) returns String value
      S::concat "Missing test file(s) for lib modules: "
        (S::join-with ", " missing)
    end

  define transparent is-missing as
    function existing (List String) path String returns Boolean value
      P::not (L::member String path existing)
    end

  define transparent missing-tests as
    function expected (List String) existing (List String) returns (List String) value
      P::filter String (is-missing existing) expected
    end

  define transparent assert-lib-tests as
    function lib-entries (List (Pair String Boolean))
             test-entries (List (Pair String Boolean))
    returns computation Unit value
      let value lib-infos be entry-infos lib-entries in
        let value test-infos be entry-infos test-entries in
          let value lib-files be lq-file-paths lib-infos in
            let value test-files be lq-file-paths test-infos in
              let value all-infos be P::append (Pair String (Pair Boolean Boolean)) lib-infos test-infos in
                let value upper-all be uppercase-paths all-infos in
                  let value expected be P::map String String lib-to-test lib-files in
                    let value missing be missing-tests expected test-files in
                      compute
                        perform (P::sequence-unit
                          [
                            (A::assert-false (uppercase-message upper-all)
                                                                                                                                                                                (P::not (L::is-empty String upper-all)))
                          , (A::assert-false (missing-message missing)
                                                                                                                                                                                  (P::not (L::is-empty String missing)))
                          ])
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

  define transparent check-lib-tests as compute
    bind lib-entries from perform (File::walk "lib") then
      bind test-entries from perform (File::walk "test") then
        perform (assert-lib-tests lib-entries test-entries)
      end
    end
  end

  define transparent main as compute
    perform (P::sequence-unit
      [
        check-lib-tests
      ])
  end
end
