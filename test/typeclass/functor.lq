import arithmetic as Ar
import assert as A
import prelude as P
import type_aliases as Types
import typeclass::equality as Eq
import typeclass::functor as Functor
import option as Option
import either as Either
import result as Result
import string as S

open P exposing Option::none Option::some Either::left Either::right Result::ok Result::err end
open Functor exposing Functor map end

module test::typeclass::functor contains
  define transparent map-value as
    function F (Types::TypeFunction Type0) A Type0 B Type0
             f (Types::Function A B)
             fa (F A)
    requires Functor F
    returns (F B) value
      map A B f fa
    end

  define transparent inc as
    function x Natural returns Natural value
      Ar::add x 1
    end

  define transparent option-some as
    map-value P::Option Natural Natural inc (Option::some Natural 1)

  define transparent option-none as
    map-value P::Option Natural Natural inc (Option::none Natural)

  define transparent option-some-ok as
    match option-some of-type (P::Option Natural) as ignored returns Boolean
      case Option::none as false
      case Option::some with x Natural as Eq::equals Natural x 2
    end

  define transparent option-none-ok as
    match option-none of-type (P::Option Natural) as ignored returns Boolean
      case Option::none as true
      case Option::some with ignored Natural as false
    end

  define transparent either-right as
    map-value (P::Either String) Natural Natural inc
      (Either::right String Natural 1)

  define transparent either-left as
    map-value (P::Either String) Natural Natural inc
      (Either::left String Natural "err")

  define transparent either-right-ok as
    match either-right of-type (P::Either String Natural) as ignored returns Boolean
      case Either::left with ignored String as false
      case Either::right with x Natural as Eq::equals Natural x 2
    end

  define transparent either-left-ok as
    match either-left of-type (P::Either String Natural) as ignored returns Boolean
      case Either::left with msg String as Eq::equals String msg "err"
      case Either::right with ignored Natural as false
    end

  define transparent result-ok as
    map-value (Result::Result-with String) Natural Natural inc
      (Result::ok Natural String 1)

  define transparent result-err as
    map-value (Result::Result-with String) Natural Natural inc
      (Result::err Natural String "boom")

  define transparent result-ok-ok as
    match result-ok of-type (P::Result Natural String) as ignored returns Boolean
      case Result::ok with x Natural as Eq::equals Natural x 2
      case Result::err with ignored String as false
    end

  define transparent result-err-ok as
    match result-err of-type (P::Result Natural String) as ignored returns Boolean
      case Result::ok with ignored Natural as false
      case Result::err with msg String as Eq::equals String msg "boom"
    end

  define transparent main as compute
    perform (P::sequence-unit
      [
        (A::assert-eq Boolean option-some-ok true)
      , (A::assert-eq Boolean option-none-ok true)
      , (A::assert-eq Boolean either-right-ok true)
      , (A::assert-eq Boolean either-left-ok true)
      , (A::assert-eq Boolean result-ok-ok true)
      , (A::assert-eq Boolean result-err-ok true)
      ])
  end
end
