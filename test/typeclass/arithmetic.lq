# Tests for Arithmetic typeclasses
# NOTE: Multi-arg typeclass methods are curried; application is left-associative.
import assert as A
import prelude as P

module test::typeclass::arithmetic contains
  # Addition typeclass
  define transparent Add as typeclass A where
    add of-type for-all x as A to for-all y as A to A
  end

  define transparent Add-Natural as instance Add Natural where
    add as function x Natural y Natural returns Natural value
      add-nat-prim x y
    end
  end

  # Subtraction typeclass
  define transparent Sub as typeclass A where
    sub of-type for-all x as A to for-all y as A to A
  end

  define transparent Sub-Natural as instance Sub Natural where
    sub as function x Natural y Natural returns Natural value
      sub-nat-prim x y
    end
  end

  # Multiplication typeclass
  define transparent Mul as typeclass A where
    mul of-type for-all x as A to for-all y as A to A
  end

  define transparent Mul-Natural as instance Mul Natural where
    mul as function x Natural y Natural returns Natural value
      mul-nat-prim x y
    end
  end

  # Division typeclass
  define transparent Div as typeclass A where
    div of-type for-all x as A to for-all y as A to A
  end

  define transparent Div-Natural as instance Div Natural where
    div as function x Natural y Natural returns Natural value
      div-nat-prim x y
    end
  end

  # Modulo typeclass
  define transparent Mod as typeclass A where
    mod of-type for-all x as A to for-all y as A to A
  end

  define transparent Mod-Natural as instance Mod Natural where
    mod as function x Natural y Natural returns Natural value
      mod-nat-prim x y
    end
  end

  # Generic helpers with constraints
  define transparent add-value as
    function A Type0 x A y A requires Add A returns A value
      add x y
    end

  define transparent sub-value as
    function A Type0 x A y A requires Sub A returns A value
      sub x y
    end

  define transparent mul-value as
    function A Type0 x A y A requires Mul A returns A value
      mul x y
    end

  define transparent div-value as
    function A Type0 x A y A requires Div A returns A value
      div x y
    end

  define transparent mod-value as
    function A Type0 x A y A requires Mod A returns A value
      mod x y
    end

  # Test add
  define transparent test-add-1 as add-value Natural 2 3
  define transparent test-add-2 as add-value Natural 0 5

  # Test sub (saturating at 0)
  define transparent test-sub-1 as sub-value Natural 10 3
  define transparent test-sub-2 as sub-value Natural 3 10

  # Test mul
  define transparent test-mul-1 as mul-value Natural 4 5
  define transparent test-mul-2 as mul-value Natural 7 0

  # Test div
  define transparent test-div-1 as div-value Natural 20 4
  define transparent test-div-2 as div-value Natural 17 5

  # Test mod
  define transparent test-mod-1 as mod-value Natural 17 5
  define transparent test-mod-2 as mod-value Natural 20 4

  # Test with variables (ETyped)
  define transparent test-add-var as
    function x Natural y Natural returns Natural value
      add-value Natural x y
    end

  define transparent test-mul-var as
    function x Natural y Natural returns Natural value
      mul-value Natural x y
    end

  define transparent main as compute
    sequence
      (A::assert-eq-nat test-add-1 5)
      (A::assert-eq-nat test-add-2 5)
      (A::assert-eq-nat test-sub-1 7)
      (A::assert-eq-nat test-sub-2 0)
      (A::assert-eq-nat test-mul-1 20)
      (A::assert-eq-nat test-mul-2 0)
      (A::assert-eq-nat test-div-1 5)
      (A::assert-eq-nat test-div-2 3)
      (A::assert-eq-nat test-mod-1 2)
      (A::assert-eq-nat test-mod-2 0)
      (A::assert-eq-nat (test-add-var 10 20) 30)
      (A::assert-eq-nat (test-mul-var 6 7) 42)
    end
  end
end
