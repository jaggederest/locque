import list as L
import prelude as P
import arithmetic as Ar
import string as S
import typeclass::equality as Eq

module path contains
  define transparent is-absolute as
    function path String returns Boolean value
      S::starts-with "/" path
    end

  define transparent drop-leading-empty as
    function xs (List String) returns (List String) value
      match xs of-type (List String) as ignored returns (List String)
        case List::empty as P::nil String
        case List::cons with h String t (List String) as
          match (Eq::equals String h "") of-type Boolean as ignored returns (List String)
            case Boolean::true as recur t
            case Boolean::false as xs
          end
      end
    end

  define transparent drop-trailing-empty as
    function xs (List String) returns (List String) value
      L::reverse String (drop-leading-empty (L::reverse String xs))
    end

  define transparent segments as
    function path String returns (List String) value
      drop-leading-empty (drop-trailing-empty (S::split-on "/" path))
    end

  define transparent NonEmptySegments as
    L::NonEmptyList String

  define transparent segments-nonempty as
    function path String returns (P::Option NonEmptySegments) value
      L::nonempty String (segments path)
    end

  define transparent segments-nonempty-value as
    function segs NonEmptySegments returns (List String) value
      L::nonempty-value String segs
    end

  define transparent join-segments as
    function has-root Boolean segs (List String) returns String value
      let value cleaned be drop-leading-empty segs in
        let value joined be S::join-with "/" cleaned in
          match has-root of-type Boolean as ignored returns String
            case Boolean::false as joined
            case Boolean::true as
              match (Eq::equals String joined "") of-type Boolean as ignored returns String
                case Boolean::true as "/"
                case Boolean::false as S::concat "/" joined
              end
          end
        end
      end
    end

  define transparent join as
    function base String child String returns String value
      match (Eq::equals String base "") of-type Boolean as ignored returns String
        case Boolean::true as child
        case Boolean::false as
          match (Eq::equals String child "") of-type Boolean as ignored returns String
            case Boolean::true as base
            case Boolean::false as
              match (is-absolute child) of-type Boolean as ignored returns String
                case Boolean::true as child
                case Boolean::false as
                  match (S::ends-with "/" base) of-type Boolean as ignored returns String
                    case Boolean::true as S::concat base child
                    case Boolean::false as S::concat base (S::concat "/" child)
                  end
              end
          end
      end
    end

  define transparent basename as
    function path String returns String value
      match (Eq::equals String path "/") of-type Boolean as ignored returns String
        case Boolean::true as "/"
        case Boolean::false as
          let value segs be segments path in
            match segs of-type (List String) as ignored returns String
              case List::empty as ""
              case List::cons with h String t (List String) as L::last String segs
            end
          end
      end
    end

  define transparent dirname as
    function path String returns String value
      match (Eq::equals String path "/") of-type Boolean as ignored returns String
        case Boolean::true as "/"
        case Boolean::false as
          let value segs be segments path in
            match segs of-type (List String) as ignored returns String
              case List::empty as ""
              case List::cons with h String t (List String) as
                join-segments (is-absolute path) (L::init String segs)
            end
          end
      end
    end

  define transparent ext as
    function path String returns String value
      let value base be basename path in
        let value len be S::length base in
          match (Eq::equals Natural len 0) of-type Boolean as ignored returns String
            case Boolean::true as ""
            case Boolean::false as
              let value rev be S::reverse base in
                let value rev-index be S::index-of "." rev in
                  match (Eq::equals Natural rev-index len) of-type Boolean as ignored returns String
                    case Boolean::true as ""
                    case Boolean::false as
                      let value len-minus-one be Ar::subtract len 1 in
                        let value dot-index be Ar::subtract len-minus-one rev-index in
                          match (Eq::equals Natural dot-index 0) of-type Boolean as ignored returns String
                            case Boolean::true as ""
                            case Boolean::false as
                              let value start be Ar::subtract len rev-index in
                                S::substring start rev-index base
                              end
                          end
                        end
                      end
                  end
                end
              end
          end
        end
      end
    end
end
