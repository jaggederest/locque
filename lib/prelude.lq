module prelude contains
  define transparent add-nat as add-nat-prim
  define transparent sub-nat as sub-nat-prim
  define transparent nil as nil-prim
  define transparent cons as cons-prim
  define transparent head as
    function A Type0 xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as error-prim A "head expects a non-empty list"
        case List::cons with h A t (List A) as h
      end
    end
  define transparent tail as
    function A Type0 xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as nil A
        case List::cons with h A t (List A) as t
      end
    end
  define transparent not as
    function x Boolean returns Boolean value
      match x of-type Boolean as ignored returns Boolean
        case Boolean::false as true
        case Boolean::true as false
      end
    end
  define transparent length-list as
    function A Type0 xs (List A) returns Natural value
      match xs of-type (List A) as ignored returns Natural
        case List::empty as 0
        case List::cons with h A t (List A) as add-nat 1 (recur A t)
      end
    end
  define transparent append as
    function A Type0 xs (List A) ys (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as ys
        case List::cons with h A t (List A) as cons A h (recur A t ys)
      end
    end
  define transparent filter as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as nil A
        case List::cons with h A t (List A) as
          let value rest be recur A predicate t in
            match (predicate h) of-type Boolean as ignored returns (List A)
              case Boolean::false as rest
              case Boolean::true as cons A h rest
            end
          end
      end
    end
  define transparent fold as
    function A Type0 B Type0 f (for-all acc as B to for-all x as A to B) acc B xs (List A) returns B value
      match xs of-type (List A) as ignored returns B
        case List::empty as acc
        case List::cons with h A t (List A) as recur A B f (f acc h) t
      end
    end
  define transparent map as
    function A Type0 B Type0 f (for-all x as A to B) xs (List A) returns (List B) value
      match xs of-type (List A) as ignored returns (List B)
        case List::empty as nil B
        case List::cons with h A t (List A) as cons B (f h) (recur A B f t)
      end
    end
  define transparent pair as pair-prim
  define transparent fst as
    function A Type0 B Type0 p (Pair A B) returns A value
      match p of-type (Pair A B) as ignored returns A
        case Pair::pair with a A b B as a
      end
    end
  define transparent snd as
    function A Type0 B Type0 p (Pair A B) returns B value
      match p of-type (Pair A B) as ignored returns B
        case Pair::pair with a A b B as b
      end
    end
  define transparent pair-to-list as
    function A Type0 p (Pair A A) returns (List A) value
      match p of-type (Pair A A) as ignored returns (List A)
        case Pair::pair with a A b A as cons A a (cons A b (nil A))
      end
    end
  define transparent decide-eq-nat as decide-eq-nat-prim
  define transparent decide-eq-string as decide-eq-string-prim
  define transparent decide-eq-bool as decide-eq-bool-prim
  define transparent decide-eq-pair as decide-eq-pair-prim
  define transparent decide-eq-list as decide-eq-list-prim
  define transparent get-line as get-line-prim

  define transparent id as
    function A Type0 x A returns A value
      x
    end

  define transparent is-falsy as
    function x Boolean returns Boolean value
      not x
    end

end
