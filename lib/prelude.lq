import logic as Lg
import type_aliases as Types

module prelude contains
  define transparent nil as List::empty
  define transparent cons as List::cons
  define transparent error as error-prim

  define transparent List-kind as
    Types::TypeFunction Type0

  define transparent Pair-kind as
    Types::BinaryTypeFunction Type0 Type0

  define transparent Dictionary-kind as
    Types::BinaryTypeFunction Type0 Type0

  define transparent Refine as Lg::Refine
  define transparent refine-value as Lg::refine-value
  define transparent refine-with as Lg::refine-with

  define transparent Option as data A Type0 in Type0
    case Option::none of-type Option A
    case Option::some of-type Types::Function A (Option A)
  end

  define transparent Option-kind as
    Types::TypeFunction Type0

  define transparent Either as data A Type0 B Type0 in Type0
    case Either::left of-type Types::Function A (Either A B)
    case Either::right of-type Types::Function B (Either A B)
  end

  define transparent Either-kind as
    Types::BinaryTypeFunction Type0 Type0

  define transparent Result as data A Type0 E Type0 in Type0
    case Result::ok of-type Types::Function A (Result A E)
    case Result::err of-type Types::Function E (Result A E)
  end

  define transparent Result-kind as
    Types::BinaryTypeFunction Type0 Type0
  define transparent head as
    function A Type0 xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as error A "head expects a non-empty list"
        case List::cons with h A t (List A) as h
      end
    end
  define transparent tail as
    function A Type0 xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as nil A
        case List::cons with h A t (List A) as t
      end
    end
  define transparent not as
    function x Boolean returns Boolean value
      match x of-type Boolean as ignored returns Boolean
        case Boolean::false as true
        case Boolean::true as false
      end
    end
  define transparent length-list as
    function A Type0 xs (List A) returns Natural value
      match xs of-type (List A) as ignored returns Natural
        case List::empty as 0
        case List::cons with h A t (List A) as add-nat-prim 1 (recur A t)
      end
    end
  define transparent append as
    function A Type0 xs (List A) ys (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as ys
        case List::cons with h A t (List A) as cons A h (recur A t ys)
      end
    end
  define transparent filter as
    function A Type0 predicate (Types::Predicate A) xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as nil A
        case List::cons with h A t (List A) as
          let value rest be recur A predicate t in
            match (predicate h) of-type Boolean as ignored returns (List A)
              case Boolean::false as rest
              case Boolean::true as cons A h rest
            end
          end
      end
    end
  define transparent fold as
    function A Type0 B Type0 f (Types::FoldStep A B) acc B xs (List A) returns B value
      match xs of-type (List A) as ignored returns B
        case List::empty as acc
        case List::cons with h A t (List A) as recur A B f (f acc h) t
      end
    end

  define transparent fold-compute as
    function A Type0 B Type0
             f (Types::BinaryFunction (computation B) A (computation B))
             acc (computation B)
             xs (List A)
    returns computation B value
      fold A (computation B) f acc xs
    end

  define transparent sequence as
    function A Type0 xs (List (computation A)) returns computation (List A) value
      match xs of-type (List (computation A)) as ignored returns computation (List A)
        case List::empty as compute return (nil A) end
        case List::cons with h (computation A) t (List (computation A)) as
          let value rest be recur A t in
            compute
              bind result from perform h then
                bind tail from perform rest then
                  return (cons A result tail)
                end
              end
            end
          end
      end
    end

  define transparent sequence-unit as
    function xs (List (computation Unit)) returns computation Unit value
      compute
        bind ignored from perform (sequence Unit xs) then
          return Unit::tt
        end
      end
    end

  define transparent forever as forever-prim

  define transparent discard as
    function A Type0 comp (computation A) returns computation Unit value
      compute
        bind ignored from perform comp then
          return Unit::tt
        end
      end
    end
  define transparent map as
    function A Type0 B Type0 f (Types::Function A B) xs (List A) returns (List B) value
      match xs of-type (List A) as ignored returns (List B)
        case List::empty as nil B
        case List::cons with h A t (List A) as cons B (f h) (recur A B f t)
      end
    end
  define transparent pair as Pair::pair
  define transparent fst as
    function A Type0 B Type0 p (Pair A B) returns A value
      match p of-type (Pair A B) as ignored returns A
        case Pair::pair with a A b B as a
      end
    end
  define transparent snd as
    function A Type0 B Type0 p (Pair A B) returns B value
      match p of-type (Pair A B) as ignored returns B
        case Pair::pair with a A b B as b
      end
    end
  define transparent pair-to-list as
    function A Type0 p (Pair A A) returns (List A) value
      match p of-type (Pair A A) as ignored returns (List A)
        case Pair::pair with a A b A as [a, b]
      end
    end

  define transparent id as
    function A Type0 x A returns A value
      x
    end

  define transparent is-falsy as
    function x Boolean returns Boolean value
      not x
    end

end
