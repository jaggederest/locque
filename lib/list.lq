import prelude as P
import comparison as C
import string as S

module list contains
  define transparent drop-until as
    function target String xs (List String) returns (List String) value
      match xs of-type (List String) as ignored returns (List String)
        empty-case as P::nil String
        cons-case with h String t (List String) as
          match (S::eq target h) of-type Boolean as ignored returns (List String)
            false-case as recur target t
            true-case as P::cons String h t
          end
      end
    end
  define transparent nth as
    function A Type0 idx Natural xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        empty-case as error-prim A "nth expects index in bounds"
        cons-case with h A t (List A) as
          match (C::eq-nat idx 0) of-type Boolean as ignored returns A
            false-case as recur A (P::sub-nat idx 1) t
            true-case as h
          end
      end
    end
  define transparent take as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        empty-case as P::nil A
        cons-case with h A t (List A) as
          match (C::eq-nat n 0) of-type Boolean as ignored returns (List A)
            false-case as P::cons A h (recur A (P::sub-nat n 1) t)
            true-case as P::nil A
          end
      end
    end
  define transparent drop as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        empty-case as P::nil A
        cons-case with h A t (List A) as
          match (C::eq-nat n 0) of-type Boolean as ignored returns (List A)
            false-case as recur A (P::sub-nat n 1) t
            true-case as P::cons A h t
          end
      end
    end
  define transparent list-last as
    function A Type0 xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        empty-case as error-prim A "last expects a non-empty list"
        cons-case with h A t (List A) as
          match t of-type (List A) as ignored returns A
            empty-case as h
            cons-case with head2 A tail2 (List A) as recur A t
          end
      end
    end
  define transparent list-init as
    function A Type0 xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        empty-case as P::nil A
        cons-case with h A t (List A) as
          match t of-type (List A) as ignored returns (List A)
            empty-case as P::nil A
            cons-case with head2 A tail2 (List A) as
              P::cons A h (recur A t)
          end
      end
    end

  define transparent is-empty as
    function A Type0 xs (List A) returns Boolean value
      match xs of-type (List A) as ignored returns Boolean
        empty-case as true
        cons-case with h A t (List A) as false
      end
    end

  define transparent length as
    function A Type0 xs (List A) returns Natural value
      P::length-list A xs
    end

  define transparent last as
    function A Type0 xs (List A) returns A value
      list-last A xs
    end

  define transparent first as
    function A Type0 xs (List A) returns A value
      P::head A xs
    end

  define transparent init as
    function A Type0 xs (List A) returns List A value
      list-init A xs
    end

  define transparent contains-string-fn as
    function item String acc Boolean x String returns Boolean value
      match acc of-type Boolean as ignored returns Boolean
        false-case as S::eq item x
        true-case as true
      end
    end

  define transparent contains-string as
    function item String xs (List String) returns Boolean value
      P::fold String Boolean (contains-string-fn item) false xs
    end

  define transparent any-fn as
    function A Type0 predicate (for-all x as A to Boolean) acc Boolean x A returns Boolean value
      match acc of-type Boolean as ignored returns Boolean
        false-case as predicate x
        true-case as true
      end
    end

  define transparent any as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Boolean value
      P::fold A Boolean (any-fn A predicate) false xs
    end

  define transparent all-fn as
    function A Type0 predicate (for-all x as A to Boolean) acc Boolean x A returns Boolean value
      match acc of-type Boolean as ignored returns Boolean
        false-case as false
        true-case as predicate x
      end
    end

  define transparent all as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Boolean value
      P::fold A Boolean (all-fn A predicate) true xs
    end

  define transparent slice as
    function A Type0 start Natural len Natural xs (List A) returns List A value
      take A len (drop A start xs)
    end

  define transparent reverse as
    function A Type0 xs (List A) returns List A value
      P::fold A (List A)
        (function acc (List A) x A returns List A value
          P::cons A x acc
        end)
        (P::nil A)
        xs
    end

  define transparent concat as
    function A Type0 xs (List (List A)) returns List A value
      P::fold (List A) (List A)
        (function acc (List A) x (List A) returns List A value
          P::append A acc x
        end)
        (P::nil A)
        xs
    end

  define transparent insert-by as
    function A Type0 cmp (for-all x as A to for-all y as A to Boolean) x A xs (List A) returns List A value
      let value step be
        function acc (Pair (List A) Boolean) y A returns (Pair (List A) Boolean) value
          match acc of-type (Pair (List A) Boolean) as ignored returns (Pair (List A) Boolean)
            pair-case with built (List A) inserted Boolean as
              match inserted of-type Boolean as ignored returns (Pair (List A) Boolean)
                false-case as
                  match (cmp x y) of-type Boolean as ignored returns (Pair (List A) Boolean)
                    false-case as
                      P::pair (List A) Boolean
                        (P::append A built (P::cons A y (P::nil A)))
                        false
                    true-case as
                      P::pair (List A) Boolean
                        (P::append A built (P::cons A x (P::cons A y (P::nil A))))
                        true
                  end
                true-case as
                  P::pair (List A) Boolean
                    (P::append A built (P::cons A y (P::nil A)))
                    inserted
              end
          end
        end
      in
        let value initial be P::pair (List A) Boolean (P::nil A) false in
          let value result be P::fold A (Pair (List A) Boolean) step initial xs in
            match result of-type (Pair (List A) Boolean) as ignored returns (List A)
              pair-case with built (List A) inserted Boolean as
                match inserted of-type Boolean as ignored returns (List A)
                  false-case as P::append A built (P::cons A x (P::nil A))
                  true-case as built
                end
            end
          end
        end
      end
    end

  define transparent sort-by as
    function A Type0 cmp (for-all x as A to for-all y as A to Boolean) xs (List A) returns List A value
      P::fold A (List A)
        (function acc (List A) x A returns List A value
          insert-by A cmp x acc
        end)
        (P::nil A)
        xs
    end

  define transparent lt-string-length as
    function a String b String returns Boolean value
      C::lt-nat (S::length a) (S::length b)
    end

  define transparent sort-strings-by-length as
    function xs (List String) returns List String value
      sort-by String lt-string-length xs
    end
end
