import prelude as P
import arithmetic as Ar
import typeclass::equality as Eq
import type_aliases as Types

open Eq exposing Equality eq end

module list contains
  define transparent drop-until as
    function A Type0 target A xs (List A) requires Equality A returns (List A) value
      let value step be
        function acc (Pair (List A) Boolean) x A returns (Pair (List A) Boolean) value
          match acc of-type (Pair (List A) Boolean) as ignored returns (Pair (List A) Boolean)
            case Pair::pair with kept (List A) found Boolean as
              match found of-type Boolean as ignored returns (Pair (List A) Boolean)
                case Boolean::true as P::pair (List A) Boolean (P::cons A x kept) true
                case Boolean::false as
                  match (eq target x) of-type Boolean as ignored returns (Pair (List A) Boolean)
                    case Boolean::true as P::pair (List A) Boolean (P::cons A x kept) true
                    case Boolean::false as P::pair (List A) Boolean kept false
                  end
              end
          end
        end
      in
        let value initial be P::pair (List A) Boolean (P::nil A) false in
          let value result be P::fold A (Pair (List A) Boolean) step initial xs in
            match result of-type (Pair (List A) Boolean) as ignored returns (List A)
              case Pair::pair with kept (List A) found Boolean as
                P::fold A (List A)
                  (function acc (List A) x A returns (List A) value
                    P::cons A x acc
                  end)
                  (P::nil A)
                  kept
            end
          end
        end
      end
    end
  define transparent nth as
    function A Type0 idx Natural xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as P::error A "nth expects index in bounds"
        case List::cons with h A t (List A) as
          match (Eq::equals Natural idx 0) of-type Boolean as ignored returns A
            case Boolean::false as recur A (Ar::subtract idx 1) t
            case Boolean::true as h
          end
      end
    end
  define transparent take as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List A)
            case Boolean::false as P::cons A h (recur A (Ar::subtract n 1) t)
            case Boolean::true as P::nil A
          end
      end
    end
  define transparent drop as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List A)
            case Boolean::false as recur A (Ar::subtract n 1) t
            case Boolean::true as P::cons A h t
          end
      end
    end
  define transparent last as
    function A Type0 xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as P::error A "last expects a non-empty list"
        case List::cons with h A t (List A) as
          match t of-type (List A) as ignored returns A
            case List::empty as h
            case List::cons with head2 A tail2 (List A) as recur A t
          end
      end
    end
  define transparent init as
    function A Type0 xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match t of-type (List A) as ignored returns (List A)
            case List::empty as P::nil A
            case List::cons with head2 A tail2 (List A) as
              P::cons A h (recur A t)
          end
      end
    end

  define transparent is-empty as
    function A Type0 xs (List A) returns Boolean value
      match xs of-type (List A) as ignored returns Boolean
        case List::empty as true
        case List::cons with h A t (List A) as false
      end
    end

  define transparent length as
    function A Type0 xs (List A) returns Natural value
      P::length-list A xs
    end

  define transparent first as
    function A Type0 xs (List A) returns A value
      P::head A xs
    end

  define transparent member as
    function A Type0 item A xs (List A) requires Equality A returns Boolean value
      P::fold A Boolean
        (function acc Boolean x A returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::false as eq item x
            case Boolean::true as true
          end
        end)
        false
        xs
    end

  define transparent any as
    function A Type0 predicate (Types::Predicate A) xs (List A) returns Boolean value
      let value step be
        function acc Boolean x A returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::false as predicate x
            case Boolean::true as true
          end
        end
      in
        P::fold A Boolean step false xs
      end
    end

  define transparent count as
    function A Type0 predicate (Types::Predicate A) xs (List A) returns Natural value
      P::fold A Natural
        (function acc Natural x A returns Natural value
          match (predicate x) of-type Boolean as ignored returns Natural
            case Boolean::true as Ar::add acc 1
            case Boolean::false as acc
          end
        end)
        0
        xs
    end

  define transparent all as
    function A Type0 predicate (Types::Predicate A) xs (List A) returns Boolean value
      let value step be
        function acc Boolean x A returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::false as false
            case Boolean::true as predicate x
          end
        end
      in
        P::fold A Boolean step true xs
      end
    end

  define transparent count-prefix as
    function A Type0 predicate (Types::Predicate A) xs (List A) returns Natural value
      match xs of-type (List A) as ignored returns Natural
        case List::empty as 0
        case List::cons with h A t (List A) as
          match (predicate h) of-type Boolean as ignored returns Natural
            case Boolean::true as Ar::add 1 (recur A predicate t)
            case Boolean::false as 0
          end
      end
    end

  define transparent slice as
    function A Type0 start Natural len Natural xs (List A) returns List A value
      take A len (drop A start xs)
    end

  define transparent reverse as
    function A Type0 xs (List A) returns List A value
      P::fold A (List A)
        (function acc (List A) x A returns List A value
          P::cons A x acc
        end)
        (P::nil A)
        xs
    end

  define transparent concat as
    function A Type0 xs (List (List A)) returns List A value
      P::fold (List A) (List A)
        (function acc (List A) x (List A) returns List A value
          P::append A acc x
        end)
        (P::nil A)
        xs
    end

  define transparent sort-by as
    function A Type0 cmp (Types::Comparator A) xs (List A) returns List A value
      let value insert-by be
        function x A ys (List A) returns List A value
          let value step be
            function acc (Pair (List A) Boolean) y A returns (Pair (List A) Boolean) value
              match acc of-type (Pair (List A) Boolean) as ignored returns (Pair (List A) Boolean)
                case Pair::pair with built (List A) inserted Boolean as
                  match inserted of-type Boolean as ignored returns (Pair (List A) Boolean)
                    case Boolean::false as
                      match (cmp x y) of-type Boolean as ignored returns (Pair (List A) Boolean)
                        case Boolean::false as
                          P::pair (List A) Boolean
                            (P::append A built [y])
                            false
                        case Boolean::true as
                          P::pair (List A) Boolean
                            (P::append A built [x, y])
                            true
                      end
                    case Boolean::true as
                      P::pair (List A) Boolean
                        (P::append A built [y])
                        inserted
                  end
              end
            end
          in
            let value initial be P::pair (List A) Boolean (P::nil A) false in
              let value result be P::fold A (Pair (List A) Boolean) step initial ys in
                match result of-type (Pair (List A) Boolean) as ignored returns (List A)
                  case Pair::pair with built (List A) inserted Boolean as
                    match inserted of-type Boolean as ignored returns (List A)
                      case Boolean::false as P::append A built [x]
                      case Boolean::true as built
                    end
                end
              end
            end
          end
        end
      in
        P::fold A (List A)
          (function acc (List A) x A returns List A value
            insert-by x acc
          end)
          (P::nil A)
          xs
      end
    end
end
