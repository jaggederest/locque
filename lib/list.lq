import prelude as P
import string as S
import typeclass::equality as Eq
import typeclass::order as Order

open Eq exposing Equality eq end

module list contains
  define transparent drop-until as
    function A Type0 target A xs (List A) requires Equality A returns (List A) value
      let value step be
        function acc (Pair (List A) Boolean) x A returns (Pair (List A) Boolean) value
          match acc of-type (Pair (List A) Boolean) as ignored returns (Pair (List A) Boolean)
            case Pair::pair with kept (List A) found Boolean as
              match found of-type Boolean as ignored returns (Pair (List A) Boolean)
                case Boolean::true as P::pair (List A) Boolean (P::cons A x kept) true
                case Boolean::false as
                  match (eq target x) of-type Boolean as ignored returns (Pair (List A) Boolean)
                    case Boolean::true as P::pair (List A) Boolean (P::cons A x kept) true
                    case Boolean::false as P::pair (List A) Boolean kept false
                  end
              end
          end
        end
      in
        let value initial be P::pair (List A) Boolean (P::nil A) false in
          let value result be P::fold A (Pair (List A) Boolean) step initial xs in
            match result of-type (Pair (List A) Boolean) as ignored returns (List A)
              case Pair::pair with kept (List A) found Boolean as
                P::fold A (List A)
                  (function acc (List A) x A returns (List A) value
                    P::cons A x acc
                  end)
                  (P::nil A)
                  kept
            end
          end
        end
      end
    end
  define transparent nth as
    function A Type0 idx Natural xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as P::error A "nth expects index in bounds"
        case List::cons with h A t (List A) as
          match (Eq::equals Natural idx 0) of-type Boolean as ignored returns A
            case Boolean::false as recur A (P::sub-nat idx 1) t
            case Boolean::true as h
          end
      end
    end
  define transparent take as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List A)
            case Boolean::false as P::cons A h (recur A (P::sub-nat n 1) t)
            case Boolean::true as P::nil A
          end
      end
    end
  define transparent drop as
    function A Type0 n Natural xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List A)
            case Boolean::false as recur A (P::sub-nat n 1) t
            case Boolean::true as P::cons A h t
          end
      end
    end
  define transparent list-last as
    function A Type0 xs (List A) returns A value
      match xs of-type (List A) as ignored returns A
        case List::empty as P::error A "last expects a non-empty list"
        case List::cons with h A t (List A) as
          match t of-type (List A) as ignored returns A
            case List::empty as h
            case List::cons with head2 A tail2 (List A) as recur A t
          end
      end
    end
  define transparent list-init as
    function A Type0 xs (List A) returns (List A) value
      match xs of-type (List A) as ignored returns (List A)
        case List::empty as P::nil A
        case List::cons with h A t (List A) as
          match t of-type (List A) as ignored returns (List A)
            case List::empty as P::nil A
            case List::cons with head2 A tail2 (List A) as
              P::cons A h (recur A t)
          end
      end
    end

  define transparent is-empty as
    function A Type0 xs (List A) returns Boolean value
      match xs of-type (List A) as ignored returns Boolean
        case List::empty as true
        case List::cons with h A t (List A) as false
      end
    end

  define transparent length as
    function A Type0 xs (List A) returns Natural value
      P::length-list A xs
    end

  define transparent last as
    function A Type0 xs (List A) returns A value
      list-last A xs
    end

  define transparent first as
    function A Type0 xs (List A) returns A value
      P::head A xs
    end

  define transparent init as
    function A Type0 xs (List A) returns List A value
      list-init A xs
    end

  define transparent member as
    function A Type0 item A xs (List A) requires Equality A returns Boolean value
      P::fold A Boolean
        (function acc Boolean x A returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::false as eq item x
            case Boolean::true as true
          end
        end)
        false
        xs
    end

  define transparent includes as
    function A Type0 item A xs (List A) requires Equality A returns Boolean value
      member A item xs
    end

  define transparent contains-string as
    function item String xs (List String) returns Boolean value
      member String item xs
    end

  define transparent any-fn as
    function A Type0 predicate (for-all x as A to Boolean) acc Boolean x A returns Boolean value
      match acc of-type Boolean as ignored returns Boolean
        case Boolean::false as predicate x
        case Boolean::true as true
      end
    end

  define transparent any as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Boolean value
      P::fold A Boolean (any-fn A predicate) false xs
    end

  define transparent count as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Natural value
      P::fold A Natural
        (function acc Natural x A returns Natural value
          match (predicate x) of-type Boolean as ignored returns Natural
            case Boolean::true as P::add-nat acc 1
            case Boolean::false as acc
          end
        end)
        0
        xs
    end

  define transparent all-fn as
    function A Type0 predicate (for-all x as A to Boolean) acc Boolean x A returns Boolean value
      match acc of-type Boolean as ignored returns Boolean
        case Boolean::false as false
        case Boolean::true as predicate x
      end
    end

  define transparent all as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Boolean value
      P::fold A Boolean (all-fn A predicate) true xs
    end

  define transparent count-prefix as
    function A Type0 predicate (for-all x as A to Boolean) xs (List A) returns Natural value
      match xs of-type (List A) as ignored returns Natural
        case List::empty as 0
        case List::cons with h A t (List A) as
          match (predicate h) of-type Boolean as ignored returns Natural
            case Boolean::true as P::add-nat 1 (recur A predicate t)
            case Boolean::false as 0
          end
      end
    end

  define transparent slice as
    function A Type0 start Natural len Natural xs (List A) returns List A value
      take A len (drop A start xs)
    end

  define transparent reverse as
    function A Type0 xs (List A) returns List A value
      P::fold A (List A)
        (function acc (List A) x A returns List A value
          P::cons A x acc
        end)
        (P::nil A)
        xs
    end

  define transparent concat as
    function A Type0 xs (List (List A)) returns List A value
      P::fold (List A) (List A)
        (function acc (List A) x (List A) returns List A value
          P::append A acc x
        end)
        (P::nil A)
        xs
    end

  define transparent insert-by as
    function A Type0 cmp (for-all x as A to for-all y as A to Boolean) x A xs (List A) returns List A value
      let value step be
        function acc (Pair (List A) Boolean) y A returns (Pair (List A) Boolean) value
          match acc of-type (Pair (List A) Boolean) as ignored returns (Pair (List A) Boolean)
            case Pair::pair with built (List A) inserted Boolean as
              match inserted of-type Boolean as ignored returns (Pair (List A) Boolean)
                case Boolean::false as
                  match (cmp x y) of-type Boolean as ignored returns (Pair (List A) Boolean)
                    case Boolean::false as
                      P::pair (List A) Boolean
                        (P::append A built (P::cons A y (P::nil A)))
                        false
                    case Boolean::true as
                      P::pair (List A) Boolean
                        (P::append A built (P::cons A x (P::cons A y (P::nil A))))
                        true
                  end
                case Boolean::true as
                  P::pair (List A) Boolean
                    (P::append A built (P::cons A y (P::nil A)))
                    inserted
              end
          end
        end
      in
        let value initial be P::pair (List A) Boolean (P::nil A) false in
          let value result be P::fold A (Pair (List A) Boolean) step initial xs in
            match result of-type (Pair (List A) Boolean) as ignored returns (List A)
              case Pair::pair with built (List A) inserted Boolean as
                match inserted of-type Boolean as ignored returns (List A)
                  case Boolean::false as P::append A built (P::cons A x (P::nil A))
                  case Boolean::true as built
                end
            end
          end
        end
      end
    end

  define transparent sort-by as
    function A Type0 cmp (for-all x as A to for-all y as A to Boolean) xs (List A) returns List A value
      P::fold A (List A)
        (function acc (List A) x A returns List A value
          insert-by A cmp x acc
        end)
        (P::nil A)
        xs
    end

  define transparent lt-string-length as
    function a String b String returns Boolean value
      Order::less-than Natural (S::length a) (S::length b)
    end

  define transparent sort-strings-by-length as
    function xs (List String) returns List String value
      sort-by String lt-string-length xs
    end
end
