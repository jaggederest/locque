import prelude as P
import typeclass::equality as Eq
import typeclass::order as Order

open Eq exposing Equality end

module string contains
  define transparent concat as concat-string-prim
  define transparent eq as eq-string-prim

  define transparent Equality-String as instance Equality String where
    eq as eq
  end

  define transparent length as
    function s String returns Natural value
      P::length-list String (string-to-list-prim s)
    end

  define transparent Character as
    there-exists c as String in
      equal Natural (length c) 1

  define transparent character as
    function s String returns Character value
      unpack (P::decide-eq-nat (length s) 1) as ok proof in
        match ok of-type Boolean as ok returns Character
          case Boolean::false as P::error Character "Character expects length 1"
          case Boolean::true as
            pack c as String in equal Natural (length c) 1 with s proof end
        end
      end
    end

  define transparent character-string as
    function c Character returns String value
      unpack c as s ignored in s end
    end

  define transparent char-code as
    function c Character returns Natural value
      char-code-prim (character-string c)
    end

  define transparent char-eq as
    function a Character b Character returns Boolean value
      eq (character-string a) (character-string b)
    end

  define transparent char-is as
    function c Character s String returns Boolean value
      eq (character-string c) s
    end

  define transparent to-list as
    function s String returns List Character value
      P::map String Character character (string-to-list-prim s)
    end

  define transparent join-with as
    function sep String xs (List String) returns String value
      match xs of-type (List String) as ignored returns String
        case List::empty as ""
        case List::cons with h String t (List String) as
          match t of-type (List String) as ignored returns String
            case List::empty as h
            case List::cons with ignored String tail (List String) as
              concat (concat h sep) (recur sep t)
          end
      end
    end

  define transparent from-list as
    function xs (List Character) returns String value
      join-with "" (P::map Character String character-string xs)
    end

  define transparent list-take as
    function n Natural xs (List Character) returns (List Character) value
      match xs of-type (List Character) as ignored returns (List Character)
        case List::empty as P::nil Character
        case List::cons with h Character t (List Character) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List Character)
            case Boolean::false as P::cons Character h (recur (P::sub-nat n 1) t)
            case Boolean::true as P::nil Character
          end
      end
    end

  define transparent list-drop as
    function n Natural xs (List Character) returns (List Character) value
      match xs of-type (List Character) as ignored returns (List Character)
        case List::empty as P::nil Character
        case List::cons with h Character t (List Character) as
          match (Eq::equals Natural n 0) of-type Boolean as ignored returns (List Character)
            case Boolean::false as recur (P::sub-nat n 1) t
            case Boolean::true as P::cons Character h t
          end
      end
    end

  define transparent list-reverse as
    function xs (List Character) returns (List Character) value
      P::fold Character (List Character)
        (function acc (List Character) x Character returns (List Character) value
          P::cons Character x acc
        end)
        (P::nil Character)
        xs
    end

  define transparent reverse-segments as
    function xs (List (List Character)) returns (List (List Character)) value
      P::fold (List Character) (List (List Character))
        (function acc (List (List Character)) x (List Character) returns (List (List Character)) value
          P::cons (List Character) x acc
        end)
        (P::nil (List Character))
        xs
    end

  define transparent drop-while-char as
    function predicate (for-all x as Character to Boolean) xs (List Character) returns (List Character) value
      match xs of-type (List Character) as ignored returns (List Character)
        case List::empty as P::nil Character
        case List::cons with h Character t (List Character) as
          match (predicate h) of-type Boolean as ignored returns (List Character)
            case Boolean::false as P::cons Character h t
            case Boolean::true as recur predicate t
          end
      end
    end

  define transparent starts-with-chars as
    function needle (List Character) haystack (List Character) returns Boolean value
      match needle of-type (List Character) as ignored returns Boolean
        case List::empty as true
        case List::cons with n Character nt (List Character) as
          match haystack of-type (List Character) as ignored returns Boolean
            case List::empty as false
            case List::cons with h Character ht (List Character) as
              match (char-eq n h) of-type Boolean as ignored returns Boolean
                case Boolean::false as false
                case Boolean::true as recur nt ht
              end
          end
      end
    end

  define transparent list-eq-chars as
    function xs (List Character) ys (List Character) returns Boolean value
      match xs of-type (List Character) as ignored returns Boolean
        case List::empty as
          match ys of-type (List Character) as ignored returns Boolean
            case List::empty as true
            case List::cons with ignored Character ignored-tail (List Character) as false
          end
        case List::cons with x Character xt (List Character) as
          match ys of-type (List Character) as ignored returns Boolean
            case List::empty as false
            case List::cons with y Character yt (List Character) as
              match (char-eq x y) of-type Boolean as ignored returns Boolean
                case Boolean::false as false
                case Boolean::true as recur xt yt
              end
          end
      end
    end

  define transparent index-of-chars as
    function haystack (List Character) needle (List Character) offset Natural returns Natural value
      match (starts-with-chars needle haystack) of-type Boolean as ignored returns Natural
        case Boolean::true as offset
        case Boolean::false as
          match haystack of-type (List Character) as ignored returns Natural
            case List::empty as offset
            case List::cons with ignored Character t (List Character) as
              recur t needle (P::add-nat offset 1)
          end
      end
    end

  define transparent string-index-of as
    function needle String haystack String returns Natural value
      index-of-chars (to-list haystack) (to-list needle) 0
    end

  define transparent string-starts-with as
    function prefix String s String returns Boolean value
      starts-with-chars (to-list prefix) (to-list s)
    end

  define transparent starts-with-any as
    function prefixes (List String) s String returns Boolean value
      P::fold String Boolean
        (function acc Boolean prefix String returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::true as true
            case Boolean::false as string-starts-with prefix s
          end
        end)
        false
        prefixes
    end

  define transparent string-ends-with as
    function suffix String s String returns Boolean value
      let value suffix-chars be to-list suffix in
        let value s-chars be to-list s in
          let value suffix-length be P::length-list Character suffix-chars in
            let value s-length be P::length-list Character s-chars in
              match (Order::less-than Natural s-length suffix-length) of-type Boolean as ignored returns Boolean
                case Boolean::true as false
                case Boolean::false as
                  list-eq-chars (list-drop (P::sub-nat s-length suffix-length) s-chars) suffix-chars
              end
            end
          end
        end
      end
    end

  define transparent string-contains as
    function needle String haystack String returns Boolean value
      match (Eq::equals Natural (length needle) 0) of-type Boolean as ignored returns Boolean
        case Boolean::true as true
        case Boolean::false as Order::less-than Natural (string-index-of needle haystack) (length haystack)
      end
    end

  define transparent contains-any as
    function needles (List String) haystack String returns Boolean value
      P::fold String Boolean
        (function acc Boolean needle String returns Boolean value
          match acc of-type Boolean as ignored returns Boolean
            case Boolean::true as true
            case Boolean::false as string-contains needle haystack
          end
        end)
        false
        needles
    end

  define transparent substring as
    function start Natural len Natural s String returns String value
      from-list (list-take len (list-drop start (to-list s)))
    end

  define transparent split-on-chars as
    function chars (List Character)
             delim (List Character)
             delim-length Natural
             skip Natural
             current (List Character)
             segments (List (List Character))
    returns (List (List Character)) value
      match chars of-type (List Character) as ignored returns (List (List Character))
        case List::empty as P::cons (List Character) (list-reverse current) segments
        case List::cons with h Character t (List Character) as
          match (Eq::equals Natural skip 0) of-type Boolean as ignored returns (List (List Character))
            case Boolean::true as
              match (starts-with-chars delim chars) of-type Boolean as ignored returns (List (List Character))
                case Boolean::true as
                  let value next-segments be P::cons (List Character) (list-reverse current) segments in
                    let value new-skip be P::sub-nat delim-length 1 in
                      recur t delim delim-length new-skip (P::nil Character) next-segments
                    end
                  end
                case Boolean::false as
                  recur t delim delim-length 0 (P::cons Character h current) segments
              end
            case Boolean::false as
              recur t delim delim-length (P::sub-nat skip 1) current segments
          end
      end
    end

  define transparent split-on as
    function delim String s String returns List String value
      match (Eq::equals Natural (length delim) 0) of-type Boolean as ignored returns (List String)
        case Boolean::true as P::error (List String) "split-on expects a non-empty delimiter"
        case Boolean::false as
          let value delim-chars be to-list delim in
            let value delim-length be P::length-list Character delim-chars in
              let value segments-rev be
                split-on-chars (to-list s) delim-chars delim-length 0
                  (P::nil Character) (P::nil (List Character))
              in
                let value segments be reverse-segments segments-rev in
                  P::map (List Character) String from-list segments
                end
              end
            end
          end
      end
    end

  define transparent char-is-space as
    function c Character returns Boolean value
      let value s be character-string c in
        match (eq s " ") of-type Boolean as ignored returns Boolean
          case Boolean::true as true
          case Boolean::false as
            match (eq s "\n") of-type Boolean as ignored returns Boolean
              case Boolean::true as true
              case Boolean::false as
                match (eq s "\t") of-type Boolean as ignored returns Boolean
                  case Boolean::true as true
                  case Boolean::false as
                    match (eq s "\r") of-type Boolean as ignored returns Boolean
                      case Boolean::true as true
                      case Boolean::false as false
                    end
                end
            end
        end
      end
    end

  define transparent trim-left as
    function s String returns String value
      let value chars be to-list s in
        from-list (drop-while-char char-is-space chars)
      end
    end

  define transparent trim as
    function s String returns String value
      let value chars be to-list s in
        let value trimmed-front be drop-while-char char-is-space chars in
          let value reversed be list-reverse trimmed-front in
            let value trimmed-back be drop-while-char char-is-space reversed in
              from-list (list-reverse trimmed-back)
            end
          end
        end
      end
    end

  define transparent nth-char as
    function index Natural xs (List Character) returns Character value
      match xs of-type (List Character) as ignored returns Character
        case List::empty as P::error Character "char-at expects index in bounds"
        case List::cons with h Character t (List Character) as
          match (Eq::equals Natural index 0) of-type Boolean as ignored returns Character
            case Boolean::false as recur (P::sub-nat index 1) t
            case Boolean::true as h
          end
      end
    end

  define transparent char-at as
    function index Natural s String returns Character value
      nth-char index (to-list s)
    end

  define transparent head as
    function s String returns Character value
      P::head Character (to-list s)
    end

  define transparent tail as
    function s String returns String value
      from-list (P::tail Character (to-list s))
    end

  define transparent ascii-order as
    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

  define transparent char-order-index as
    function c Character returns Natural value
      string-index-of (character-string c) ascii-order
    end

  define transparent code-in-range as
    function index Natural start Natural stop Natural returns Boolean value
      match (Order::less-or-equal Natural start index) of-type Boolean as ignored returns Boolean
        case Boolean::false as false
        case Boolean::true as Order::less-or-equal Natural index stop
      end
    end

  define transparent char-in-range as
    function c Character start Character stop Character returns Boolean value
      code-in-range (char-code c) (char-code start) (char-code stop)
    end

  define transparent digit-start-code as
    char-code-prim "0"

  define transparent digit-end-code as
    char-code-prim "9"

  define transparent upper-start-code as
    char-code-prim "A"

  define transparent upper-end-code as
    char-code-prim "Z"

  define transparent lower-start-code as
    char-code-prim "a"

  define transparent lower-end-code as
    char-code-prim "z"

  define transparent char-is-digit as
    function c Character returns Boolean value
      code-in-range (char-code c) digit-start-code digit-end-code
    end

  define transparent char-is-upper as
    function c Character returns Boolean value
      code-in-range (char-code c) upper-start-code upper-end-code
    end

  define transparent char-is-lower as
    function c Character returns Boolean value
      code-in-range (char-code c) lower-start-code lower-end-code
    end

  define transparent char-is-letter as
    function c Character returns Boolean value
      let value code be char-code c in
        match (code-in-range code upper-start-code upper-end-code)
        of-type Boolean as ignored returns Boolean
          case Boolean::true as true
          case Boolean::false as code-in-range code lower-start-code lower-end-code
        end
      end
    end

  define transparent char-is-alnum as
    function c Character returns Boolean value
      let value code be char-code c in
        match (code-in-range code upper-start-code upper-end-code)
        of-type Boolean as ignored returns Boolean
          case Boolean::true as true
          case Boolean::false as
            match (code-in-range code lower-start-code lower-end-code)
            of-type Boolean as ignored returns Boolean
              case Boolean::true as true
              case Boolean::false as code-in-range code digit-start-code digit-end-code
            end
        end
      end
    end

  define transparent char-is-word as
    function c Character returns Boolean value
      match (char-is-alnum c) of-type Boolean as ignored returns Boolean
        case Boolean::true as true
        case Boolean::false as
          match (char-is c "_") of-type Boolean as ignored returns Boolean
            case Boolean::true as true
            case Boolean::false as
              match (char-is c "-") of-type Boolean as ignored returns Boolean
                case Boolean::true as true
                case Boolean::false as char-is c ":"
              end
          end
      end
    end

  define transparent char-lt as
    function a Character b Character returns Boolean value
      Order::less-than Natural (char-order-index a) (char-order-index b)
    end

  define transparent insert-char-by as
    function cmp (for-all x as Character to for-all y as Character to Boolean)
             x Character
             xs (List Character)
    returns (List Character) value
      match xs of-type (List Character) as ignored returns (List Character)
        case List::empty as P::cons Character x (P::nil Character)
        case List::cons with h Character t (List Character) as
          match (cmp x h) of-type Boolean as ignored returns (List Character)
            case Boolean::false as P::cons Character h (recur cmp x t)
            case Boolean::true as P::cons Character x (P::cons Character h t)
          end
      end
    end

  define transparent sort-chars-by as
    function cmp (for-all x as Character to for-all y as Character to Boolean)
             xs (List Character)
    returns (List Character) value
      P::fold Character (List Character)
        (function acc (List Character) x Character returns (List Character) value
          insert-char-by cmp x acc
        end)
        (P::nil Character)
        xs
    end

  define transparent sort as
    function s String returns String value
      from-list (sort-chars-by char-lt (to-list s))
    end

  define transparent is-empty as
    function s String returns Boolean value
      Eq::equals Natural (length s) 0
    end

  define transparent is-whitespace as
    function s String returns Boolean value
      eq (trim s) ""
    end

  define transparent ends-with as
    function suffix String s String returns Boolean value
      string-ends-with suffix s
    end

  define transparent index-of as
    function needle String haystack String returns Natural value
      string-index-of needle haystack
    end

  define transparent reverse as
    function s String returns String value
      from-list (list-reverse (to-list s))
    end

  define transparent lines as
    function s String returns List String value
      split-on "\n" s
    end

  define transparent unlines as
    function xs (List String) returns String value
      join-with "\n" xs
    end

  define transparent split-spaces as
    function s String returns List String value
      let value trimmed be trim s in
        P::filter String
          (function x String returns Boolean value
            P::not (is-empty x)
          end)
          (split-on " " trimmed)
      end
    end

  define transparent words as
    function s String returns List String value
      split-spaces s
    end

  define transparent unwords as
    function xs (List String) returns String value
      join-with " " xs
    end

  define transparent slice as
    function start Natural len Natural s String returns String value
      substring start len s
    end
end
