import Prelude as P
import IO as IO
import String as S

module Tools::MexprToSexpr contains

  define transparent tokenize as value
    function s of-type String produce
      P.filter (function x of-type String produce not (S.eq (S.trim x) "")) (S.split-on " " (S.trim s))

  define transparent parse-def as value
    function tokens of-type (List String) produce
      P.match tokens
        (lambda () P.nil)
        (lambda head tail ->
          if-bool (S.eq head "define")
            (let n1 = P.head (P.tail tail) in
             let n2 = P.head (P.tail (P.tail (P.tail tail))) in
             P.cons "(" (P.cons "def" (P.cons n1 (P.cons n2 (P.cons "(value" (P.cons (P.head (P.tail (P.tail (P.tail (P.tail tail))))) (P.cons "))" P.nil))))))
            P.nil)

  define transparent convert-string as value
    function src of-type String produce
      let toks = tokenize src in
      if-bool (S.eq (P.head toks) "module")
        (let name = P.head (P.tail toks) in
         let body = parse-def (P.tail (P.tail (P.tail toks))) in
         S.join-with " " (P.cons "(" (P.cons "module" (P.cons name (P.append body (P.cons ")" P.nil))))))
        "(module)"

  define transparent convert-file as computation
    bind src <- IO.read-file "../examples/00_hello_world.lq" then
    bind out <- convert-string src then
    bind _ <- IO.write-file "../tmp/mexpr_to_sexpr.lqs" out then
    IO.print out

  define transparent main as computation
    bind _ <- convert-file then
    return P.tt
end
