import prelude as P
import arithmetic as Ar
import string as S
import list as L
import file as File
import path as Path
import cli as Cli
import natural as N
import io as IO
import typeclass::order as Order
import type_aliases as Types
import tools::tokenizer as Tokenizer
import tools::formatter_indent as Indent

module tools::formatter contains
  define transparent indent-step as Indent::indent-step

  define transparent FormatState as data in Type0
    case FormatState::state of-type
      Types::BinaryFunction Natural Natural
        (Types::BinaryFunction Natural Boolean
          (Types::BinaryFunction Natural (List String) FormatState))
  end

  define transparent line-comment-prefixes as
    [
      "#"
    , ";"
    ]

  define transparent block-comment-openers as
    [
      "/*"
    , "#|"
    ]

  define transparent block-comment-closers as
    [
      "*/"
    , "|#"
    ]

  define transparent format-error as
    function path String line Natural msg String returns String value
      S::concat path (S::concat ":" (S::concat (N::to-string line) (S::concat ": " msg)))
    end

  define transparent indent-error-message as
    function expected Natural actual Natural returns String value
      S::concat "expected indent at least "
        (S::concat (N::to-string expected)
          (S::concat " but found " (N::to-string actual)))
    end

  define transparent add-error as
    function msg String errors (List String) returns (List String) value
      P::cons String msg errors
    end

  define transparent add-error-when as
    function cond Boolean msg String errors (List String) returns (List String) value
      match cond of-type Boolean as ignored returns (List String)
        case Boolean::true as add-error msg errors
        case Boolean::false as errors
      end
    end

  define transparent choose as
    function A Type0 cond Boolean yes A no A returns A value
      match cond of-type Boolean as ignored returns A
        case Boolean::true as yes
        case Boolean::false as no
      end
    end

  define transparent next-state as
    function indent Natural pending Natural pending-line Natural in-block Boolean line-no Natural errors (List String)
    returns FormatState value
      FormatState::state indent pending pending-line in-block (Ar::add line-no 1) errors
    end

  define transparent add-tab-errors as
    function path String line-no Natural line String errors (List String) returns (List String) value
      add-error-when
        (Tokenizer::line-has-tab-outside-string line)
        (format-error path line-no "tabs are not allowed")
        errors
    end

  define transparent is-ignored-line as
    function trimmed String returns Boolean value
      match (S::is-empty trimmed) of-type Boolean as ignored returns Boolean
        case Boolean::true as true
        case Boolean::false as
          S::starts-with-any line-comment-prefixes trimmed
      end
    end

  define transparent block-comment-start as
    function trimmed String returns Boolean value
      S::starts-with-any block-comment-openers trimmed
    end

  define transparent block-comment-closed as
    function trimmed String returns Boolean value
      match (S::starts-with "/*" trimmed) of-type Boolean as ignored returns Boolean
        case Boolean::true as S::has-substring "*/" trimmed
        case Boolean::false as S::has-substring "|#" trimmed
      end
    end

  define transparent handle-block-line as
    function indent Natural pending Natural pending-line Natural line-no Natural errors (List String) line String
    returns FormatState value
      let value closed be
        S::contains-any block-comment-closers line
      in
        let value in-block-next be P::not closed in
          next-state indent pending pending-line in-block-next line-no errors
        end
      end
    end

  define transparent handle-block-start as
    function indent Natural pending Natural pending-line Natural line-no Natural errors (List String) trimmed String
    returns FormatState value
      let value closed be block-comment-closed trimmed in
        let value in-block-next be P::not closed in
          next-state indent pending pending-line in-block-next line-no errors
        end
      end
    end

  define transparent indent-ok as
    function actual Natural expected Natural returns Boolean value
      Order::greater-or-equal Natural actual expected
    end

  define transparent indent-after as
    function indent Natural tokens (List String) returns (Pair Natural Boolean) value
      let value total-ends be
        L::count String
          (function token String returns Boolean value
            S::eq token "end"
          end)
          tokens
      in
        let value has-function be
          L::any String
            (function token String returns Boolean value
              S::eq token "function"
            end)
            tokens
        in
          let value openers be Indent::count-openers has-function tokens in
            let value total-dedent be Indent::indent-width total-ends in
              let value indent-plus be Ar::add indent (Indent::indent-width openers) in
                let value underflow-after be Order::less-than Natural indent-plus total-dedent in
                  let value next-indent be Ar::subtract indent-plus total-dedent in
                    P::pair Natural Boolean next-indent underflow-after
                  end
                end
              end
            end
          end
        end
    end
    end

  define transparent indent-state as
    function path String indent Natural pending Natural pending-line Natural line-no Natural errors (List String)
             line String tokens (List String) block-start Boolean
    returns FormatState value
      let value actual be Indent::leading-spaces (S::to-list line) in
        let value leading-ends be Indent::count-leading-ends tokens in
          let value leading-dedent be Indent::indent-width leading-ends in
            let value underflow-before be Order::less-than Natural indent leading-dedent in
              let value base-indent be Ar::subtract indent leading-dedent in
                let value expected-indent be Ar::add base-indent pending in
                  let value errors1 be
                    add-error-when
                      underflow-before
                      (format-error path line-no "unexpected end")
                      errors
                  in
                    let value only-ends be
                      L::all String
                        (function token String returns Boolean value
                          S::eq token "end"
                        end)
                        tokens
                    in
                      let value starts-then be
                        match tokens of-type (List String) as ignored returns Boolean
                          case List::empty as false
                          case List::cons with h String t (List String) as S::eq h "then"
                        end
                      in
                        let value skip-indent-check be
                          match only-ends of-type Boolean as ignored returns Boolean
                            case Boolean::true as true
                            case Boolean::false as starts-then
                          end
                        in
                          let value indent-ok-value be
                            match skip-indent-check of-type Boolean as ignored returns Boolean
                              case Boolean::true as true
                              case Boolean::false as indent-ok actual expected-indent
                            end
                          in
                            let value errors2 be
                              add-error-when
                                (P::not indent-ok-value)
                                (format-error path line-no (indent-error-message expected-indent actual))
                                errors1
                            in
                              match (indent-after indent tokens) of-type (Pair Natural Boolean) as ignored returns FormatState
                                case Pair::pair with next-indent Natural underflow-after Boolean as
                                  let value errors3 be
                                    match underflow-after of-type Boolean as ignored returns (List String)
                                      case Boolean::true as
                                        add-error-when
                                          (P::not underflow-before)
                                          (format-error path line-no "unexpected end")
                                          errors2
                                      case Boolean::false as errors2
                                    end
                                  in
                                    let value case-pending be Indent::is-case-line tokens in
                                      let value pending-next be
                                        choose Natural case-pending Indent::indent-step 0
                                      in
                                        let value pending-line-next be
                                          choose Natural case-pending line-no 0
                                        in
                                          FormatState::state
                                            next-indent
                                            pending-next
                                            pending-line-next
                                            block-start
                                            (Ar::add line-no 1)
                                            errors3
                                        end
                                      end
                                    end
                              end
                            end
                          end
                        end
                      end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

  define transparent handle-code-line as
    function path String indent Natural pending Natural pending-line Natural line-no Natural errors (List String) line String
    returns FormatState value
      match (Tokenizer::scan-line line) of-type (Pair (List String) Boolean) as ignored returns FormatState
        case Pair::pair with tokens (List String) block-start Boolean as
          match tokens of-type (List String) as ignored returns FormatState
            case List::empty as next-state indent pending pending-line block-start line-no errors
            case List::cons with ignored String ignored-tokens (List String) as
              indent-state path indent pending pending-line line-no errors line tokens block-start
          end
      end
    end

  define transparent step-line as
    function path String st FormatState line String returns FormatState value
      match st of-type FormatState as ignored returns FormatState
        case FormatState::state
          with indent Natural
               pending Natural
               pending-line Natural
               in-block Boolean
               line-no Natural
               errors (List String)
        as
          let value errors0 be add-tab-errors path line-no line errors in
            match in-block of-type Boolean as ignored returns FormatState
              case Boolean::true as
                handle-block-line indent pending pending-line line-no errors0 line
              case Boolean::false as
                let value trimmed be S::trim-left line in
                  match (is-ignored-line trimmed) of-type Boolean as ignored returns FormatState
                    case Boolean::true as
                      next-state indent pending pending-line false line-no errors0
                    case Boolean::false as
                      match (block-comment-start trimmed) of-type Boolean as ignored returns FormatState
                        case Boolean::true as
                          handle-block-start indent pending pending-line line-no errors0 trimmed
                        case Boolean::false as
                          handle-code-line path indent pending pending-line line-no errors0 line
                      end
                  end
              end
              end
              end
      end
    end

  define transparent check-lines as
    function path String lines (List String) returns (List String) value
      let value initial be
        FormatState::state 0 0 0 false 1 (P::nil String)
      in
        let value final be
          P::fold String FormatState (step-line path) initial lines
        in
          match final of-type FormatState as ignored returns (List String)
            case FormatState::state
              with indent Natural
                   pending Natural
                   pending-line Natural
                   in-block Boolean
                   line-no Natural
                   errors (List String)
            as
              let value errors1 be
                match (Order::greater-than Natural indent 0) of-type Boolean as ignored returns (List String)
                  case Boolean::true as
                    add-error
                      (format-error path (Ar::subtract line-no 1) "missing end (indentation not closed)")
                      errors
                  case Boolean::false as errors
                end
              in
                let value errors2 be
                  match (Order::greater-than Natural pending 0) of-type Boolean as ignored returns (List String)
                    case Boolean::true as
                      add-error
                        (format-error path pending-line "case body missing after 'as'")
                        errors1
                    case Boolean::false as errors1
                  end
                in
                  let value errors3 be
                    match in-block of-type Boolean as ignored returns (List String)
                      case Boolean::true as
                        add-error
                          (format-error path (Ar::subtract line-no 1) "unterminated block comment")
                          errors2
                      case Boolean::false as errors2
                    end
                  in
                    L::reverse String errors3
                  end
                end
              end
          end
        end
      end
    end

  define transparent check-file as
    function path String returns computation (List String) value
      compute
        bind lines from perform (File::read-lines path) then
          return (check-lines path lines)
        end
      end
    end

  define transparent is-lq as
    function path String returns Boolean value
      S::eq (Path::ext path) "lq"
    end

  define transparent skip-patterns as
    [
      "node_modules"
    , "/node_modules/"
    , ".git"
    , "/.git/"
    , "dist-newstyle"
    , "/dist-newstyle/"
    , ".stack-work"
    , "/.stack-work/"
    , "tmp/"
    , "/tmp/"
    ]

  define transparent should-skip-path as
    function path String returns Boolean value
      L::any String
        (function pat String returns Boolean value
          S::has-substring pat path
        end)
        skip-patterns
    end

  define transparent lq-files-from-walk as
    function entries (List (Pair String Boolean)) returns (List String) value
      let value collected be
        P::fold (Pair String Boolean) (List String)
          (function acc (List String) entry (Pair String Boolean) returns (List String) value
            let value path be File::walk-path entry in
              let value is-dir be File::walk-is-directory entry in
                match is-dir of-type Boolean as ignored returns (List String)
                  case Boolean::true as acc
                  case Boolean::false as
                    match (should-skip-path path) of-type Boolean as ignored returns (List String)
                      case Boolean::true as acc
                      case Boolean::false as
                        match (is-lq path) of-type Boolean as ignored returns (List String)
                          case Boolean::true as P::cons String path acc
                          case Boolean::false as acc
                        end
                    end
                end
              end
            end
          end)
          (P::nil String)
          entries
      in
        L::reverse String collected
      end
    end

  define transparent collect-files as
    function target String returns computation (List String) value
      compute
        bind exists from perform (File::path-exists target) then
          perform
            (match exists of-type Boolean as ignored returns (computation (List String))
              case Boolean::false as
                compute return (P::error (List String) (S::concat "format: path not found: " target)) end
              case Boolean::true as
                compute
                  bind is-file from perform (File::is-file target) then
                    perform
                      (match is-file of-type Boolean as ignored returns (computation (List String))
                        case Boolean::true as
                          match (is-lq target) of-type Boolean as ignored returns (computation (List String))
                            case Boolean::true as compute return [target] end
                            case Boolean::false as
                              compute
                                return
                                  (P::error (List String)
                                    (S::concat "format: expected .lq file, got " target))
                              end
                          end
                        case Boolean::false as
                          compute
                            bind is-dir from perform (File::is-directory target) then
                              perform
                                (match is-dir of-type Boolean as ignored returns (computation (List String))
                                  case Boolean::true as
                                    compute
                                      bind entries from perform (File::walk target) then
                                        return (lq-files-from-walk entries)
                                      end
                                    end
                                  case Boolean::false as
                                    compute
                                      return
                                        (P::error (List String)
                                          (S::concat "format: not a file or directory: " target))
                                    end
                                end)
                            end
                          end
                      end)
                  end
                end
            end)
        end
      end
    end

  define transparent check-files as
    function files (List String) returns computation (List String) value
      let value step be
        function acc (computation (List String)) path String returns computation (List String) value
          compute
            bind current from perform acc then
              bind next from perform (check-file path) then
                return (P::append String current next)
              end
            end
          end
        end
      in
        P::fold-compute String (List String) step (compute return (P::nil String) end) files
      end
    end

  define transparent has-flag as
    function name String flags (List (Pair String String)) returns Boolean value
      L::any (Pair String String)
        (function flag (Pair String String) returns Boolean value
          match flag of-type (Pair String String) as ignored returns Boolean
            case Pair::pair with key String val String as S::eq key name
          end
        end)
        flags
    end

  define transparent print-errors as
    function errors (List String) returns computation Unit value
      let value step be
        function acc (computation Unit) msg String returns computation Unit value
          compute
            bind ignored from perform acc then
              perform (IO::print msg)
            end
          end
        end
      in
        P::fold-compute String Unit step (compute return tt end) errors
      end
    end

  define transparent default-targets as
    [
      "lib"
    , "test"
    , "Smythfile.lq"
    ]

  define transparent collect-targets as
    function targets (List String) returns computation (List String) value
      let value step be
        function acc (computation (List String)) target String returns computation (List String) value
          compute
            bind current from perform acc then
              bind next from perform (collect-files target) then
                return (P::append String current next)
              end
            end
          end
        end
      in
        P::fold-compute String (List String) step (compute return (P::nil String) end) targets
      end
    end

  define transparent run-with-options as
    function opts (Pair (List String) (List (Pair String String))) returns computation Unit value
      let value positionals be Cli::options-positionals opts in
        let value flags be Cli::options-flags opts in
          let value wants-edit be
            match (has-flag "edit" flags) of-type Boolean as ignored returns Boolean
              case Boolean::true as true
              case Boolean::false as has-flag "in-place" flags
            end
          in
            match wants-edit of-type Boolean as ignored returns (computation Unit)
              case Boolean::true as
                compute
                  return
                    (P::error Unit "format: --edit/--in-place not implemented yet")
                end
              case Boolean::false as
                let value targets be
                  match positionals of-type (List String) as ignored returns (List String)
                    case List::empty as default-targets
                    case List::cons with h String t (List String) as P::cons String h t
                  end
                in
                  compute
                    bind files from perform (collect-targets targets) then
                      bind errors from perform (check-files files) then
                        perform
                          (match (L::is-empty String errors) of-type Boolean as ignored returns (computation Unit)
                            case Boolean::true as compute return tt end
                            case Boolean::false as
                              compute
                                bind ignored from perform (print-errors errors) then
                                  return (P::error Unit "formatting failed")
                                end
                              end
                          end)
                      end
                    end
                  end
            end
        end
      end
    end
    end
    end

  define transparent main as compute
    bind opts from perform Cli::options then
      perform (run-with-options opts)
    end
  end
end
